{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 # Projectile Motion Analysis 1. Theoretical Foundation Projectile motion describes the motion of an object thrown into the air, subject only to gravitational acceleration . The equations of motion for a projectile (assuming no air resistance) are derived from Newton's Second Law: Horizontal motion (constant velocity): $$ x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t $$ Vertical motion (accelerated motion): $$ y(t) = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 $$ Where: - \\( v_0 \\) : initial velocity - \\( \\theta \\) : launch angle - \\( g \\) : gravitational acceleration (9.81 m/s\u00b2) Different values of \\( v_0 \\) and \\( \\theta \\) yield different trajectories \u2014 these are the \"family of solutions\". 2. Analysis of the Range The horizontal range \\( R \\) of a projectile launched from ground level is given by: $$ R = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} $$ Observations: The range is maximum at \\( \\theta = 45^\\circ \\) . Increasing \\( v_0 \\) increases range quadratically. Increasing \\( g \\) (stronger gravity) reduces range. 3. Practical Applications Projectile motion is used in: - Sports: calculating ball trajectories in football or basketball. - Engineering: designing trajectories in robotics or military. - Gaming & Simulation: realistic arc movement in game physics. For more accurate models, air resistance , wind , or uneven terrain can be added. 4. Implementation: JavaScript Simulation with Plotly Adjust the angle using the slider to observe how range changes. Angle: 45 \u00b0 function simulateProjectile(angleDeg) { const v0 = 50; // initial velocity (m/s) const g = 9.81; // gravity (m/s^2) const theta = angleDeg * Math.PI / 180; const t_flight = (2 * v0 * Math.sin(theta)) / g; let xData = [], yData = []; for (let t = 0; t <= t_flight; t += 0.05) { const x = v0 * Math.cos(theta) * t; const y = v0 * Math.sin(theta) * t - 0.5 * g * t * t; if (y >= 0) { xData.push(x); yData.push(y); } } const trace = { x: xData, y: yData, mode: 'lines+markers', name: `\u03b8 = ${angleDeg}\u00b0`, line: { shape: 'spline' } }; const layout = { title: 'Projectile Motion Trajectory', xaxis: { title: 'Horizontal Distance (m)' }, yaxis: { title: 'Vertical Height (m)' } }; Plotly.newPlot('plot', [trace], layout); } const slider = document.getElementById('angleSlider'); const angleLabel = document.getElementById('angleValue'); slider.addEventListener('input', () => { const angle = parseInt(slider.value); angleLabel.textContent = angle; simulateProjectile(angle); }); // Initial plot simulateProjectile(parseInt(slider.value));","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"# Projectile Motion Analysis","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Projectile motion describes the motion of an object thrown into the air, subject only to gravitational acceleration . The equations of motion for a projectile (assuming no air resistance) are derived from Newton's Second Law: Horizontal motion (constant velocity): $$ x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t $$ Vertical motion (accelerated motion): $$ y(t) = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 $$ Where: - \\( v_0 \\) : initial velocity - \\( \\theta \\) : launch angle - \\( g \\) : gravitational acceleration (9.81 m/s\u00b2) Different values of \\( v_0 \\) and \\( \\theta \\) yield different trajectories \u2014 these are the \"family of solutions\".","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The horizontal range \\( R \\) of a projectile launched from ground level is given by: $$ R = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} $$","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#observations","text":"The range is maximum at \\( \\theta = 45^\\circ \\) . Increasing \\( v_0 \\) increases range quadratically. Increasing \\( g \\) (stronger gravity) reduces range.","title":"Observations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Projectile motion is used in: - Sports: calculating ball trajectories in football or basketball. - Engineering: designing trajectories in robotics or military. - Gaming & Simulation: realistic arc movement in game physics. For more accurate models, air resistance , wind , or uneven terrain can be added.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-javascript-simulation-with-plotly","text":"Adjust the angle using the slider to observe how range changes. Angle: 45 \u00b0 function simulateProjectile(angleDeg) { const v0 = 50; // initial velocity (m/s) const g = 9.81; // gravity (m/s^2) const theta = angleDeg * Math.PI / 180; const t_flight = (2 * v0 * Math.sin(theta)) / g; let xData = [], yData = []; for (let t = 0; t <= t_flight; t += 0.05) { const x = v0 * Math.cos(theta) * t; const y = v0 * Math.sin(theta) * t - 0.5 * g * t * t; if (y >= 0) { xData.push(x); yData.push(y); } } const trace = { x: xData, y: yData, mode: 'lines+markers', name: `\u03b8 = ${angleDeg}\u00b0`, line: { shape: 'spline' } }; const layout = { title: 'Projectile Motion Trajectory', xaxis: { title: 'Horizontal Distance (m)' }, yaxis: { title: 'Vertical Height (m)' } }; Plotly.newPlot('plot', [trace], layout); } const slider = document.getElementById('angleSlider'); const angleLabel = document.getElementById('angleValue'); slider.addEventListener('input', () => { const angle = parseInt(slider.value); angleLabel.textContent = angle; simulateProjectile(angle); }); // Initial plot simulateProjectile(parseInt(slider.value));","title":"4. Implementation: JavaScript Simulation with Plotly"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Forced Damped Pendulum Simulation body { background: #111; /* Koyu arka plan */ color: #ddd; /* Genel metin i\u00e7in a\u00e7\u0131k gri */ font-family: sans-serif; line-height: 1.6; max-width: 800px; margin: auto; padding: 30px; } h1, h2 { color:#eee; /* Ba\u015fl\u0131klar i\u00e7in daha a\u00e7\u0131k bir renk, \u00f6rne\u011fin a\u00e7\u0131k gri */ } canvas { background: #222; border: 1px solid #555; display: block; margin: 20px auto; } .controls { margin-top: 20px; text-align: left; } label { margin: 0 10px; } input { width: 60px; } Forced Damped Pendulum Simulation 1. Theoretical Foundation The motion of a forced damped pendulum is governed by the nonlinear differential equation: $$ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{l} \\sin \\theta = A \\cos(\\omega t) $$ Where: \\( \\theta \\): angular displacement \\( b \\): damping coefficient \\( \\frac{g}{l} \\): natural frequency term \\( A \\cos(\\omega t) \\): external periodic driving force 2. Analysis of Dynamics Observe how the damping \\( b \\), amplitude \\( A \\), and frequency \\( \\omega \\) affect the pendulum's motion. Study the transition from periodic to chaotic motion. Explore phase-space behavior and long-term stability. 3. Practical Applications Energy harvesting systems Suspension bridge dynamics Oscillating circuits and resonance control 4. Interactive Simulation Use the controls below to adjust the damping coefficient, driving amplitude, and frequency. The animation updates in real-time. Damping (b): Amplitude (A): Frequency (\u03c9): const canvas = document.getElementById(\"canvas\"); const ctx = canvas.getContext(\"2d\"); const l = 150; // Length of pendulum (pixels) const g = 9.81; // Gravitational constant let theta = Math.PI / 3; // Initial angle let omega = 0; // Angular velocity let time = 0; const dt = 0.02; function getParams() { return { b: parseFloat(document.getElementById(\"damping\").value), A: parseFloat(document.getElementById(\"amplitude\").value), w: parseFloat(document.getElementById(\"omega\").value) }; } function drawPendulum(x, y) { ctx.clearRect(0, 0, canvas.width, canvas.height); // Draw pendulum rod ctx.beginPath(); ctx.moveTo(canvas.width / 2, 100); ctx.lineTo(canvas.width / 2 + x, 100 + y); ctx.strokeStyle = \"#88f\"; ctx.lineWidth = 3; ctx.stroke(); // Draw pendulum bob ctx.beginPath(); ctx.arc(canvas.width / 2 + x, 100 + y, 15, 0, 2 * Math.PI); ctx.fillStyle = \"#ffcc00\"; ctx.fill(); } function update() { const { b, A, w } = getParams(); // \u03b8'' + b \u03b8' + (g/l) sin(\u03b8) = A cos(\u03c9t) const alpha = -b * omega - (g / l) * Math.sin(theta) + A * Math.cos(w * time); omega += alpha * dt; theta += omega * dt; time += dt; const x = l * Math.sin(theta); const y = l * Math.cos(theta); drawPendulum(x, y); requestAnimationFrame(update); } update(); 5. Next Steps Add phase space diagrams (\u03b8 vs. \u03c9) to analyze energy distribution. Plot Poincar\u00e9 sections to visualize chaotic regimes. Export simulation data for further analysis in Python or MATLAB.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"Forced Damped Pendulum Simulation body { background: #111; /* Koyu arka plan */ color: #ddd; /* Genel metin i\u00e7in a\u00e7\u0131k gri */ font-family: sans-serif; line-height: 1.6; max-width: 800px; margin: auto; padding: 30px; } h1, h2 { color:#eee; /* Ba\u015fl\u0131klar i\u00e7in daha a\u00e7\u0131k bir renk, \u00f6rne\u011fin a\u00e7\u0131k gri */ } canvas { background: #222; border: 1px solid #555; display: block; margin: 20px auto; } .controls { margin-top: 20px; text-align: left; } label { margin: 0 10px; } input { width: 60px; }","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Derivation of Kepler's Third Law for Circular Orbits Newton's Law of Universal Gravitation: The gravitational force (F g \u200b ) between two objects with masses m 1 \u200b and m 2 \u200b , separated by a distance r, is given by: F g \u200b =G r 2 m 1 \u200b m 2 \u200b \u200b where G is the gravitational constant (6.674\u00d710 \u221211 N\u22c5m 2 /kg 2 ). Centripetal Force: For an object moving in a circular orbit, the centripetal force (F c \u200b ) required to keep it in that orbit is given by: F c \u200b = r m 2 \u200b v 2 \u200b where m 2 \u200b is the mass of the orbiting object, v is its orbital velocity, and r is the orbital radius. Orbital Velocity: For a circular orbit, the distance traveled in one orbital period (T) is the circumference of the circle, 2\u03c0r. So, the orbital velocity is: v= T 2\u03c0r \u200b Equating Forces: In a stable circular orbit, the gravitational force provides the necessary centripetal force: F g \u200b =F c \u200b G r 2 m 1 \u200b m 2 \u200b \u200b = r m 2 \u200b v 2 \u200b Substituting Orbital Velocity: Substitute the expression for v into the equation: G r 2 m 1 \u200b m 2 \u200b \u200b = r m 2 \u200b \u200b ( T 2\u03c0r \u200b ) 2 G r 2 m 1 \u200b \u200b = r 1 \u200b T 2 4\u03c0 2 r 2 \u200b G r 2 m 1 \u200b \u200b = T 2 4\u03c0 2 r \u200b Rearranging for Kepler's Third Law: Rearrange the equation to isolate T 2 : T 2 = Gm 1 \u200b 4\u03c0 2 r 3 \u200b This equation shows that for circular orbits, the square of the orbital period (T 2 ) is directly proportional to the cube of the orbital radius (r 3 ). The constant of proportionality is Gm 1 \u200b 4\u03c0 2 \u200b , where m 1 \u200b is the mass of the central body. This is a special case of Kepler's Third Law of Planetary Motion. Implications for Astronomy This relationship, a cornerstone of celestial mechanics, has profound implications for astronomy: Calculating Planetary Masses: If we know the orbital period (T) and radius (r) of a satellite (natural or artificial) orbiting a planet, we can calculate the mass of the central planet (m 1 \u200b ). m 1 \u200b = GT 2 4\u03c0 2 r 3 \u200b This method was crucial for determining the masses of planets in our Solar System before space probes could directly measure them. For example, by observing the orbit of Earth's Moon, we can accurately determine Earth's mass. Similarly, the orbits of Jupiter's Galilean moons allowed for the calculation of Jupiter's mass. Calculating Distances to Celestial Bodies: If the mass of the central body is known, and the orbital period of an orbiting object can be observed, the orbital radius (distance) can be calculated. This is particularly useful for objects where direct distance measurement is challenging. Discovering Exoplanets: While Kepler's Third Law is most directly applied to orbital parameters, its principles underpin the methods used to detect exoplanets. For example, the radial velocity method (Doppler spectroscopy) observes the wobble of a star caused by an orbiting planet. The period of this wobble directly relates to the planet's orbital period, and coupled with stellar mass estimates, can give insights into the orbital radius and minimum mass of the exoplanet. Understanding Orbital Dynamics: It provides a fundamental framework for understanding how gravitational forces govern the motion of objects in space, from asteroids to galaxies. Real-World Examples Moon's Orbit around Earth: Orbital Period (T): Approximately 27.3 days (sidereal period) \u22482.36\u00d710 6 seconds Average Orbital Radius (r): Approximately 3.84\u00d710 8 meters Using Earth's mass (m Earth \u200b \u22485.97\u00d710 24 kg) and the gravitational constant (G), we can verify this relationship. Orbits of Planets in the Solar System around the Sun: Kepler's original observation was that for all planets orbiting the Sun, the ratio r 3 T 2 \u200b is approximately constant. This is because m 1 \u200b in the equation (m Sun \u200b ) is constant for all planets in our Solar System. Let's consider Earth and Mars orbiting the Sun: Earth: T Earth \u200b \u2248365.25 days\u22483.156\u00d710 7 s r Earth \u200b \u22481.496\u00d710 11 m (1 AU) T Earth 2 \u200b /r Earth 3 \u200b \u2248(3.156\u00d710 7 ) 2 /(1.496\u00d710 11 ) 3 \u22482.97\u00d710 \u221219 s 2 /m 3 Mars: T Mars \u200b \u2248687 days\u22485.93\u00d710 7 s r Mars \u200b \u22482.279\u00d710 11 m (1.52 AU) T Mars 2 \u200b /r Mars 3 \u200b \u2248(5.93\u00d710 7 ) 2 /(2.279\u00d710 11 ) 3 \u22482.98\u00d710 \u221219 s 2 /m 3 As you can see, the ratio is indeed very close for both planets, demonstrating Kepler's Third Law. The slight differences arise from using average orbital radii for elliptical orbits. Computational Model to Simulate Circular Orbits We can implement a simple computational model using Python to simulate a circular orbit and verify the relationship. This simulation will use numerical integration (Euler method for simplicity, though more accurate methods like Runge-Kutta would be preferred for real-world simulations) to update the position and velocity of the orbiting body. Python import numpy as np import matplotlib.pyplot as plt Constants G = 6.674e-11 # Gravitational constant (N m^2 / kg^2) def simulate_circular_orbit(M_central, r_orbit, dt, num_steps): \"\"\" Simulates a circular orbit and returns orbital period and a list of positions. Args: M_central (float): Mass of the central body (kg). r_orbit (float): Desired orbital radius (m). dt (float): Time step for simulation (s). num_steps (int): Number of simulation steps. Returns: tuple: (orbital_period, positions_x, positions_y) \"\"\" # Calculate initial orbital velocity for a circular orbit # F_g = F_c => G * M_central * m_orb / r^2 = m_orb * v^2 / r # v = sqrt(G * M_central / r) v_initial = np.sqrt(G * M_central / r_orbit) # Initial conditions x = r_orbit y = 0.0 vx = 0.0 vy = v_initial positions_x = [x] positions_y = [y] # Track for period calculation start_time = 0 period_found = False orbital_period = 0 for i in range(num_steps): r = np.sqrt(x**2 + y**2) # Calculate gravitational force components Fx = -G * M_central * x / r**3 Fy = -G * M_central * y / r**3 # Update velocities (assuming orbiting mass m_orb = 1 for acceleration calculation) ax = Fx ay = Fy vx += ax * dt vy += ay * dt # Update positions x += vx * dt y += vy * dt positions_x.append(x) positions_y.append(y) # Simple period detection: When it crosses the initial y-axis going down if not period_found and y < 0 and positions_y[-2] >= 0: # Estimate period based on time elapsed orbital_period = (i + 1) * dt period_found = True # For more accuracy, one could interpolate to find the exact crossing point return orbital_period, positions_x, positions_y --- Simulation Parameters --- M_sun = 1.989e30 # Mass of the Sun (kg) R_earth_orbit = 1.496e11 # Earth's orbital radius (m) (1 AU) dt_sim = 10000 # Time step (s) - larger for faster simulation, but less accurate num_steps_sim = int(365 * 24 * 3600 / dt_sim * 1.5) # Simulate for ~1.5 Earth years print(f\"Simulating orbit with M_central = {M_sun:.2e} kg, R_orbit = {R_earth_orbit:.2e} m\") print(f\"Simulation time step (dt) = {dt_sim} s, Number of steps = {num_steps_sim}\") Run simulation for Earth's orbit period_earth_sim, x_earth_sim, y_earth_sim = simulate_circular_orbit(M_sun, R_earth_orbit, dt_sim, num_steps_sim) print(f\"\\nSimulated Earth Orbital Period: {period_earth_sim / (24 * 3600):.2f} days\") print(f\"Theoretical Earth Orbital Period: {365.25:.2f} days\") --- Verify Kepler's Third Law (T^2 vs r^3) --- Let's simulate for a few different radii orbital_radii = np.array([0.5, 1.0, 1.5, 2.0, 2.5]) * R_earth_orbit # in meters simulated_periods = [] print(\"\\nVerifying Kepler's Third Law for different orbital radii:\") for r_o in orbital_radii: # Adjust num_steps for longer periods num_steps_current = int(num_steps_sim * (r_o / R_earth_orbit)**1.5 * 1.2) # ~1.2 times the expected period period, _, _ = simulate_circular_orbit(M_sun, r_o, dt_sim, num_steps_current) simulated_periods.append(period) print(f\" Radius: {r_o/R_earth_orbit:.1f} AU, Simulated Period: {period / (24 * 3600):.2f} days\") simulated_periods = np.array(simulated_periods) Calculate T^2 and r^3 T_squared = simulated_periods 2 r_cubed = orbital_radii 3 Calculate the ratio T^2 / r^3 ratios = T_squared / r_cubed print(f\"\\nSimulated T^2 / r^3 Ratios (should be constant):\") for i, r_o in enumerate(orbital_radii): print(f\" For R = {r_o/R_earth_orbit:.1f} AU: {ratios[i]:.2e} s^2/m^3\") Theoretical constant: 4 * pi^2 / (G * M_central) theoretical_constant = (4 * np.pi**2) / (G * M_sun) print(f\"Theoretical (4 * pi^2) / (G * M_sun): {theoretical_constant:.2e} s^2/m^3\") --- Graphical Representation --- plt.figure(figsize=(12, 6)) Plot circular orbit plt.subplot(1, 2, 1) plt.plot(x_earth_sim, y_earth_sim, label='Simulated Earth Orbit') plt.plot(0, 0, 'o', color='red', markersize=8, label='Sun') # Central body plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.title('Simulated Circular Orbit (Earth around Sun)') plt.grid(True) plt.axis('equal') plt.legend() Plot T^2 vs r^3 plt.subplot(1, 2, 2) plt.plot(r_cubed, T_squared, 'o-', label=' \\(T^2\\) vs \\(r^3\\) (Simulated)') plt.xlabel('Orbital Radius Cubed ( \\(r^3\\) ) (m \\(^3\\) )') plt.ylabel('Orbital Period Squared ( \\(T^2\\) ) (s \\(^2\\) )') plt.title('Kepler\\'s Third Law: \\(T^2\\) vs \\(r^3\\) ') plt.grid(True) plt.legend() plt.tight_layout() plt.show() Discussion on Extension to Elliptical Orbits and Other Celestial Bodies Kepler's Third Law, as derived for circular orbits, states T 2 = Gm 1 \u200b 4\u03c0 2 r 3 \u200b . When extended to elliptical orbits, the orbital radius r is replaced by the semi-major axis a of the ellipse. So, for elliptical orbits, Kepler's Third Law becomes: T 2 = G(m 1 \u200b +m 2 \u200b ) 4\u03c0 2 a 3 \u200b Here, m 1 \u200b is the mass of the central body, and m 2 \u200b is the mass of the orbiting body. Mass Correction: The more accurate form of Kepler's Third Law includes the sum of the masses of both bodies (m 1 \u200b +m 2 \u200b ). In many cases, especially when m 1 \u200b \u226bm 2 \u200b (e.g., Sun and a planet), m 2 \u200b is negligible, and the simpler form T 2 = Gm 1 \u200b 4\u03c0 2 a 3 \u200b is a very good approximation. However, for systems where the masses are comparable (e.g., binary star systems or a planet with a relatively large moon), the sum of masses becomes significant. Other Celestial Bodies: This generalized form of Kepler's Third Law applies universally to any two celestial bodies orbiting each other under their mutual gravitational attraction, whether they are: Planets orbiting a star: As seen in our Solar System and exoplanetary systems. Moons orbiting a planet: Like Earth's Moon, or the many moons of Jupiter and Saturn. Binary star systems: Two stars orbiting their common center of mass. Galaxies orbiting each other: Though at this scale, other forces and dark matter play significant roles, the fundamental gravitational principles still apply. Artificial satellites orbiting Earth: Used to precisely determine their orbits and predict their positions.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#constants","text":"G = 6.674e-11 # Gravitational constant (N m^2 / kg^2) def simulate_circular_orbit(M_central, r_orbit, dt, num_steps): \"\"\" Simulates a circular orbit and returns orbital period and a list of positions. Args: M_central (float): Mass of the central body (kg). r_orbit (float): Desired orbital radius (m). dt (float): Time step for simulation (s). num_steps (int): Number of simulation steps. Returns: tuple: (orbital_period, positions_x, positions_y) \"\"\" # Calculate initial orbital velocity for a circular orbit # F_g = F_c => G * M_central * m_orb / r^2 = m_orb * v^2 / r # v = sqrt(G * M_central / r) v_initial = np.sqrt(G * M_central / r_orbit) # Initial conditions x = r_orbit y = 0.0 vx = 0.0 vy = v_initial positions_x = [x] positions_y = [y] # Track for period calculation start_time = 0 period_found = False orbital_period = 0 for i in range(num_steps): r = np.sqrt(x**2 + y**2) # Calculate gravitational force components Fx = -G * M_central * x / r**3 Fy = -G * M_central * y / r**3 # Update velocities (assuming orbiting mass m_orb = 1 for acceleration calculation) ax = Fx ay = Fy vx += ax * dt vy += ay * dt # Update positions x += vx * dt y += vy * dt positions_x.append(x) positions_y.append(y) # Simple period detection: When it crosses the initial y-axis going down if not period_found and y < 0 and positions_y[-2] >= 0: # Estimate period based on time elapsed orbital_period = (i + 1) * dt period_found = True # For more accuracy, one could interpolate to find the exact crossing point return orbital_period, positions_x, positions_y","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_1/#-simulation-parameters-","text":"M_sun = 1.989e30 # Mass of the Sun (kg) R_earth_orbit = 1.496e11 # Earth's orbital radius (m) (1 AU) dt_sim = 10000 # Time step (s) - larger for faster simulation, but less accurate num_steps_sim = int(365 * 24 * 3600 / dt_sim * 1.5) # Simulate for ~1.5 Earth years print(f\"Simulating orbit with M_central = {M_sun:.2e} kg, R_orbit = {R_earth_orbit:.2e} m\") print(f\"Simulation time step (dt) = {dt_sim} s, Number of steps = {num_steps_sim}\")","title":"--- Simulation Parameters ---"},{"location":"1%20Physics/2%20Gravity/Problem_1/#run-simulation-for-earths-orbit","text":"period_earth_sim, x_earth_sim, y_earth_sim = simulate_circular_orbit(M_sun, R_earth_orbit, dt_sim, num_steps_sim) print(f\"\\nSimulated Earth Orbital Period: {period_earth_sim / (24 * 3600):.2f} days\") print(f\"Theoretical Earth Orbital Period: {365.25:.2f} days\")","title":"Run simulation for Earth's orbit"},{"location":"1%20Physics/2%20Gravity/Problem_1/#-verify-keplers-third-law-t2-vs-r3-","text":"","title":"--- Verify Kepler's Third Law (T^2 vs r^3) ---"},{"location":"1%20Physics/2%20Gravity/Problem_1/#lets-simulate-for-a-few-different-radii","text":"orbital_radii = np.array([0.5, 1.0, 1.5, 2.0, 2.5]) * R_earth_orbit # in meters simulated_periods = [] print(\"\\nVerifying Kepler's Third Law for different orbital radii:\") for r_o in orbital_radii: # Adjust num_steps for longer periods num_steps_current = int(num_steps_sim * (r_o / R_earth_orbit)**1.5 * 1.2) # ~1.2 times the expected period period, _, _ = simulate_circular_orbit(M_sun, r_o, dt_sim, num_steps_current) simulated_periods.append(period) print(f\" Radius: {r_o/R_earth_orbit:.1f} AU, Simulated Period: {period / (24 * 3600):.2f} days\") simulated_periods = np.array(simulated_periods)","title":"Let's simulate for a few different radii"},{"location":"1%20Physics/2%20Gravity/Problem_1/#calculate-t2-and-r3","text":"T_squared = simulated_periods 2 r_cubed = orbital_radii 3","title":"Calculate T^2 and r^3"},{"location":"1%20Physics/2%20Gravity/Problem_1/#calculate-the-ratio-t2-r3","text":"ratios = T_squared / r_cubed print(f\"\\nSimulated T^2 / r^3 Ratios (should be constant):\") for i, r_o in enumerate(orbital_radii): print(f\" For R = {r_o/R_earth_orbit:.1f} AU: {ratios[i]:.2e} s^2/m^3\")","title":"Calculate the ratio T^2 / r^3"},{"location":"1%20Physics/2%20Gravity/Problem_1/#theoretical-constant-4-pi2-g-m_central","text":"theoretical_constant = (4 * np.pi**2) / (G * M_sun) print(f\"Theoretical (4 * pi^2) / (G * M_sun): {theoretical_constant:.2e} s^2/m^3\")","title":"Theoretical constant: 4 * pi^2 / (G * M_central)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#-graphical-representation-","text":"plt.figure(figsize=(12, 6))","title":"--- Graphical Representation ---"},{"location":"1%20Physics/2%20Gravity/Problem_1/#plot-circular-orbit","text":"plt.subplot(1, 2, 1) plt.plot(x_earth_sim, y_earth_sim, label='Simulated Earth Orbit') plt.plot(0, 0, 'o', color='red', markersize=8, label='Sun') # Central body plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.title('Simulated Circular Orbit (Earth around Sun)') plt.grid(True) plt.axis('equal') plt.legend()","title":"Plot circular orbit"},{"location":"1%20Physics/2%20Gravity/Problem_1/#plot-t2-vs-r3","text":"plt.subplot(1, 2, 2) plt.plot(r_cubed, T_squared, 'o-', label=' \\(T^2\\) vs \\(r^3\\) (Simulated)') plt.xlabel('Orbital Radius Cubed ( \\(r^3\\) ) (m \\(^3\\) )') plt.ylabel('Orbital Period Squared ( \\(T^2\\) ) (s \\(^2\\) )') plt.title('Kepler\\'s Third Law: \\(T^2\\) vs \\(r^3\\) ') plt.grid(True) plt.legend() plt.tight_layout() plt.show() Discussion on Extension to Elliptical Orbits and Other Celestial Bodies Kepler's Third Law, as derived for circular orbits, states T 2 = Gm 1 \u200b 4\u03c0 2 r 3 \u200b . When extended to elliptical orbits, the orbital radius r is replaced by the semi-major axis a of the ellipse. So, for elliptical orbits, Kepler's Third Law becomes: T 2 = G(m 1 \u200b +m 2 \u200b ) 4\u03c0 2 a 3 \u200b Here, m 1 \u200b is the mass of the central body, and m 2 \u200b is the mass of the orbiting body. Mass Correction: The more accurate form of Kepler's Third Law includes the sum of the masses of both bodies (m 1 \u200b +m 2 \u200b ). In many cases, especially when m 1 \u200b \u226bm 2 \u200b (e.g., Sun and a planet), m 2 \u200b is negligible, and the simpler form T 2 = Gm 1 \u200b 4\u03c0 2 a 3 \u200b is a very good approximation. However, for systems where the masses are comparable (e.g., binary star systems or a planet with a relatively large moon), the sum of masses becomes significant. Other Celestial Bodies: This generalized form of Kepler's Third Law applies universally to any two celestial bodies orbiting each other under their mutual gravitational attraction, whether they are: Planets orbiting a star: As seen in our Solar System and exoplanetary systems. Moons orbiting a planet: Like Earth's Moon, or the many moons of Jupiter and Saturn. Binary star systems: Two stars orbiting their common center of mass. Galaxies orbiting each other: Though at this scale, other forces and dark matter play significant roles, the fundamental gravitational principles still apply. Artificial satellites orbiting Earth: Used to precisely determine their orbits and predict their positions.","title":"Plot T^2 vs r^3"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}