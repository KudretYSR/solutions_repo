{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 # Projectile Motion Analysis 1. Theoretical Foundation Projectile motion describes the motion of an object thrown into the air, subject only to gravitational acceleration . The equations of motion for a projectile (assuming no air resistance) are derived from Newton's Second Law: Horizontal motion (constant velocity): $$ x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t $$ Vertical motion (accelerated motion): $$ y(t) = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 $$ Where: - \\( v_0 \\) : initial velocity - \\( \\theta \\) : launch angle - \\( g \\) : gravitational acceleration (9.81 m/s\u00b2) Different values of \\( v_0 \\) and \\( \\theta \\) yield different trajectories \u2014 these are the \"family of solutions\". 2. Analysis of the Range The horizontal range \\( R \\) of a projectile launched from ground level is given by: $$ R = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} $$ Observations: The range is maximum at \\( \\theta = 45^\\circ \\) . Increasing \\( v_0 \\) increases range quadratically. Increasing \\( g \\) (stronger gravity) reduces range. 3. Practical Applications Projectile motion is used in: - Sports: calculating ball trajectories in football or basketball. - Engineering: designing trajectories in robotics or military. - Gaming & Simulation: realistic arc movement in game physics. For more accurate models, air resistance , wind , or uneven terrain can be added. 4. Implementation: JavaScript Simulation with Plotly Adjust the angle using the slider to observe how range changes. Angle: 45 \u00b0 function simulateProjectile(angleDeg) { const v0 = 50; // initial velocity (m/s) const g = 9.81; // gravity (m/s^2) const theta = angleDeg * Math.PI / 180; const t_flight = (2 * v0 * Math.sin(theta)) / g; let xData = [], yData = []; for (let t = 0; t <= t_flight; t += 0.05) { const x = v0 * Math.cos(theta) * t; const y = v0 * Math.sin(theta) * t - 0.5 * g * t * t; if (y >= 0) { xData.push(x); yData.push(y); } } const trace = { x: xData, y: yData, mode: 'lines+markers', name: `\u03b8 = ${angleDeg}\u00b0`, line: { shape: 'spline' } }; const layout = { title: 'Projectile Motion Trajectory', xaxis: { title: 'Horizontal Distance (m)' }, yaxis: { title: 'Vertical Height (m)' } }; Plotly.newPlot('plot', [trace], layout); } const slider = document.getElementById('angleSlider'); const angleLabel = document.getElementById('angleValue'); slider.addEventListener('input', () => { const angle = parseInt(slider.value); angleLabel.textContent = angle; simulateProjectile(angle); }); // Initial plot simulateProjectile(parseInt(slider.value));","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"# Projectile Motion Analysis","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Projectile motion describes the motion of an object thrown into the air, subject only to gravitational acceleration . The equations of motion for a projectile (assuming no air resistance) are derived from Newton's Second Law: Horizontal motion (constant velocity): $$ x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t $$ Vertical motion (accelerated motion): $$ y(t) = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 $$ Where: - \\( v_0 \\) : initial velocity - \\( \\theta \\) : launch angle - \\( g \\) : gravitational acceleration (9.81 m/s\u00b2) Different values of \\( v_0 \\) and \\( \\theta \\) yield different trajectories \u2014 these are the \"family of solutions\".","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The horizontal range \\( R \\) of a projectile launched from ground level is given by: $$ R = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} $$","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#observations","text":"The range is maximum at \\( \\theta = 45^\\circ \\) . Increasing \\( v_0 \\) increases range quadratically. Increasing \\( g \\) (stronger gravity) reduces range.","title":"Observations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Projectile motion is used in: - Sports: calculating ball trajectories in football or basketball. - Engineering: designing trajectories in robotics or military. - Gaming & Simulation: realistic arc movement in game physics. For more accurate models, air resistance , wind , or uneven terrain can be added.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-javascript-simulation-with-plotly","text":"Adjust the angle using the slider to observe how range changes. Angle: 45 \u00b0 function simulateProjectile(angleDeg) { const v0 = 50; // initial velocity (m/s) const g = 9.81; // gravity (m/s^2) const theta = angleDeg * Math.PI / 180; const t_flight = (2 * v0 * Math.sin(theta)) / g; let xData = [], yData = []; for (let t = 0; t <= t_flight; t += 0.05) { const x = v0 * Math.cos(theta) * t; const y = v0 * Math.sin(theta) * t - 0.5 * g * t * t; if (y >= 0) { xData.push(x); yData.push(y); } } const trace = { x: xData, y: yData, mode: 'lines+markers', name: `\u03b8 = ${angleDeg}\u00b0`, line: { shape: 'spline' } }; const layout = { title: 'Projectile Motion Trajectory', xaxis: { title: 'Horizontal Distance (m)' }, yaxis: { title: 'Vertical Height (m)' } }; Plotly.newPlot('plot', [trace], layout); } const slider = document.getElementById('angleSlider'); const angleLabel = document.getElementById('angleValue'); slider.addEventListener('input', () => { const angle = parseInt(slider.value); angleLabel.textContent = angle; simulateProjectile(angle); }); // Initial plot simulateProjectile(parseInt(slider.value));","title":"4. Implementation: JavaScript Simulation with Plotly"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Forced Damped Pendulum Simulation body { background: #111; /* Koyu arka plan */ color: #ddd; /* Genel metin i\u00e7in a\u00e7\u0131k gri */ font-family: sans-serif; line-height: 1.6; max-width: 800px; margin: auto; padding: 30px; } h1, h2 { color:#eee; /* Ba\u015fl\u0131klar i\u00e7in daha a\u00e7\u0131k bir renk, \u00f6rne\u011fin a\u00e7\u0131k gri */ } canvas { background: #222; border: 1px solid #555; display: block; margin: 20px auto; } .controls { margin-top: 20px; text-align: left; } label { margin: 0 10px; } input { width: 60px; } Forced Damped Pendulum Simulation 1. Theoretical Foundation The motion of a forced damped pendulum is governed by the nonlinear differential equation: $$ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{l} \\sin \\theta = A \\cos(\\omega t) $$ Where: \\( \\theta \\): angular displacement \\( b \\): damping coefficient \\( \\frac{g}{l} \\): natural frequency term \\( A \\cos(\\omega t) \\): external periodic driving force 2. Analysis of Dynamics Observe how the damping \\( b \\), amplitude \\( A \\), and frequency \\( \\omega \\) affect the pendulum's motion. Study the transition from periodic to chaotic motion. Explore phase-space behavior and long-term stability. 3. Practical Applications Energy harvesting systems Suspension bridge dynamics Oscillating circuits and resonance control 4. Interactive Simulation Use the controls below to adjust the damping coefficient, driving amplitude, and frequency. The animation updates in real-time. Damping (b): Amplitude (A): Frequency (\u03c9): const canvas = document.getElementById(\"canvas\"); const ctx = canvas.getContext(\"2d\"); const l = 150; // Length of pendulum (pixels) const g = 9.81; // Gravitational constant let theta = Math.PI / 3; // Initial angle let omega = 0; // Angular velocity let time = 0; const dt = 0.02; function getParams() { return { b: parseFloat(document.getElementById(\"damping\").value), A: parseFloat(document.getElementById(\"amplitude\").value), w: parseFloat(document.getElementById(\"omega\").value) }; } function drawPendulum(x, y) { ctx.clearRect(0, 0, canvas.width, canvas.height); // Draw pendulum rod ctx.beginPath(); ctx.moveTo(canvas.width / 2, 100); ctx.lineTo(canvas.width / 2 + x, 100 + y); ctx.strokeStyle = \"#88f\"; ctx.lineWidth = 3; ctx.stroke(); // Draw pendulum bob ctx.beginPath(); ctx.arc(canvas.width / 2 + x, 100 + y, 15, 0, 2 * Math.PI); ctx.fillStyle = \"#ffcc00\"; ctx.fill(); } function update() { const { b, A, w } = getParams(); // \u03b8'' + b \u03b8' + (g/l) sin(\u03b8) = A cos(\u03c9t) const alpha = -b * omega - (g / l) * Math.sin(theta) + A * Math.cos(w * time); omega += alpha * dt; theta += omega * dt; time += dt; const x = l * Math.sin(theta); const y = l * Math.cos(theta); drawPendulum(x, y); requestAnimationFrame(update); } update(); 5. Next Steps Add phase space diagrams (\u03b8 vs. \u03c9) to analyze energy distribution. Plot Poincar\u00e9 sections to visualize chaotic regimes. Export simulation data for further analysis in Python or MATLAB.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"Forced Damped Pendulum Simulation body { background: #111; /* Koyu arka plan */ color: #ddd; /* Genel metin i\u00e7in a\u00e7\u0131k gri */ font-family: sans-serif; line-height: 1.6; max-width: 800px; margin: auto; padding: 30px; } h1, h2 { color:#eee; /* Ba\u015fl\u0131klar i\u00e7in daha a\u00e7\u0131k bir renk, \u00f6rne\u011fin a\u00e7\u0131k gri */ } canvas { background: #222; border: 1px solid #555; display: block; margin: 20px auto; } .controls { margin-top: 20px; text-align: left; } label { margin: 0 10px; } input { width: 60px; }","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 2 Orbital Period vs Radius: Kepler's Third Law 1. Theoretical Derivation Kepler\u2019s Third Law establishes a powerful relationship in orbital mechanics: for a body in a circular orbit, the square of its orbital period \\(T\\) is proportional to the cube of the orbital radius \\(r\\) . This can be derived using Newton\u2019s Law of Universal Gravitation and the formula for centripetal force. Derivation: Gravitational force equals centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplify: \\[ v = \\sqrt{\\frac{G M}{r}} \\] Orbital period \\(T\\) is: \\[ T = \\frac{2\\pi r}{v} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Squaring both sides: \\[ T^2 = \\frac{4\\pi^2}{G M} \\cdot r^3 \\] Thus: \\[ T^2 \\propto r^3 \\] 2. Astronomical Implications This relationship is crucial in astronomy for: Calculating the mass of central bodies (e.g., planets, stars). Determining orbital distances of celestial bodies. Understanding the architecture of planetary systems . Because the constant: \\[ \\frac{4\\pi^2}{GM} \\] depends only on the central mass \\(M\\) , this proportionality holds for all bodies orbiting the same object. 3. Real-World Examples Example 1: The Moon Orbital radius: \\(\\sim 384,400\\) km Orbital period: \\(\\sim 27.3\\) days \\[ T^2 = (27.3)^2 = 745.29 \\] Example 2: Planets in the Solar System Planet Radius (AU) Period (years) \\(T^2 / r^3\\) Earth 1.00 1.00 1.00 Mars 1.52 1.88 \\(\\sim 1.00\\) Jupiter 5.20 11.86 \\(\\sim 1.00\\) The ratio \\(T^2 / r^3\\) remains approximately constant. 4. Python Simulation: Orbital Period vs Radius ```python import numpy as np import plotly.graph_objects as go Constants G = 6.67430e-11 # gravitational constant [m^3/kg/s^2] M = 5.972e24 # mass of Earth [kg] Orbital radii (in meters) radii = np.linspace(7e6, 5e8, 500) periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # seconds Convert to readable units radii_km = radii / 1e3 periods_hr = periods / 3600 Plot T vs r fig1 = go.Figure() fig1.add_trace(go.Scatter(x=radii_km, y=periods_hr, mode='lines', name='T vs r')) fig1.update_layout(title='Orbital Period vs Radius', xaxis_title='Radius (km)', yaxis_title='Period (hours)', template='plotly_white') Plot T^2 vs r^3 fig2 = go.Figure() fig2.add_trace(go.Scatter(x=radii 3, y=periods 2, mode='lines', name='T\u00b2 vs r\u00b3')) fig2.update_layout(title='T\u00b2 vs r\u00b3 - Verifying Kepler\\'s Law', xaxis_title='Radius\u00b3 (m\u00b3)', yaxis_title='Period\u00b2 (s\u00b2)', template='plotly_white') fig1.show() fig2.show()","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-vs-radius-keplers-third-law","text":"","title":"Orbital Period vs Radius: Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-derivation","text":"Kepler\u2019s Third Law establishes a powerful relationship in orbital mechanics: for a body in a circular orbit, the square of its orbital period \\(T\\) is proportional to the cube of the orbital radius \\(r\\) . This can be derived using Newton\u2019s Law of Universal Gravitation and the formula for centripetal force.","title":"1. Theoretical Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation","text":"Gravitational force equals centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplify: \\[ v = \\sqrt{\\frac{G M}{r}} \\] Orbital period \\(T\\) is: \\[ T = \\frac{2\\pi r}{v} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Squaring both sides: \\[ T^2 = \\frac{4\\pi^2}{G M} \\cdot r^3 \\] Thus: \\[ T^2 \\propto r^3 \\]","title":"Derivation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-astronomical-implications","text":"This relationship is crucial in astronomy for: Calculating the mass of central bodies (e.g., planets, stars). Determining orbital distances of celestial bodies. Understanding the architecture of planetary systems . Because the constant: \\[ \\frac{4\\pi^2}{GM} \\] depends only on the central mass \\(M\\) , this proportionality holds for all bodies orbiting the same object.","title":"2. Astronomical Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-examples","text":"","title":"3. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-1-the-moon","text":"Orbital radius: \\(\\sim 384,400\\) km Orbital period: \\(\\sim 27.3\\) days \\[ T^2 = (27.3)^2 = 745.29 \\]","title":"Example 1: The Moon"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-2-planets-in-the-solar-system","text":"Planet Radius (AU) Period (years) \\(T^2 / r^3\\) Earth 1.00 1.00 1.00 Mars 1.52 1.88 \\(\\sim 1.00\\) Jupiter 5.20 11.86 \\(\\sim 1.00\\) The ratio \\(T^2 / r^3\\) remains approximately constant.","title":"Example 2: Planets in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-python-simulation-orbital-period-vs-radius","text":"```python import numpy as np import plotly.graph_objects as go","title":"4. Python Simulation: Orbital Period vs Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#constants","text":"G = 6.67430e-11 # gravitational constant [m^3/kg/s^2] M = 5.972e24 # mass of Earth [kg]","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-radii-in-meters","text":"radii = np.linspace(7e6, 5e8, 500) periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # seconds","title":"Orbital radii (in meters)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#convert-to-readable-units","text":"radii_km = radii / 1e3 periods_hr = periods / 3600","title":"Convert to readable units"},{"location":"1%20Physics/2%20Gravity/Problem_1/#plot-t-vs-r","text":"fig1 = go.Figure() fig1.add_trace(go.Scatter(x=radii_km, y=periods_hr, mode='lines', name='T vs r')) fig1.update_layout(title='Orbital Period vs Radius', xaxis_title='Radius (km)', yaxis_title='Period (hours)', template='plotly_white')","title":"Plot T vs r"},{"location":"1%20Physics/2%20Gravity/Problem_1/#plot-t2-vs-r3","text":"fig2 = go.Figure() fig2.add_trace(go.Scatter(x=radii 3, y=periods 2, mode='lines', name='T\u00b2 vs r\u00b3')) fig2.update_layout(title='T\u00b2 vs r\u00b3 - Verifying Kepler\\'s Law', xaxis_title='Radius\u00b3 (m\u00b3)', yaxis_title='Period\u00b2 (s\u00b2)', template='plotly_white') fig1.show() fig2.show()","title":"Plot T^2 vs r^3"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Definitions and Physical Meaning First Cosmic Velocity (v\u2081): The minimum speed required for an object to achieve a stable circular orbit around a celestial body at a low altitude (close to the surface). It is also known as the orbital velocity. The object remains bound to the body but orbits without falling back. Second Cosmic Velocity (v\u2082): The escape velocity, the minimum speed needed for an object to escape the gravitational pull of a celestial body and move into interplanetary space without further propulsion. At this speed, the object's kinetic energy equals its gravitational potential energy at the surface. Third Cosmic Velocity (v\u2083): The minimum speed required for an object to escape the gravitational influence of a star system (e.g., the Solar System) and travel into interstellar space. This velocity accounts for escaping both the planet's gravity and the star's gravity from the planet's orbit. Mathematical Derivations First Cosmic Velocity (Orbital Velocity): For a circular orbit, the centripetal force required for circular motion is provided by gravitational attraction:[\\frac{m v\u2081\u00b2}{r} = \\frac{G M m}{r\u00b2}]where (m) is the mass of the object, (M) is the mass of the celestial body, (r) is the radius of the orbit (approximately the body's radius for low orbits), and (G) is the gravitational constant ((G = 6.67430 \\times 10^{-11} , \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2})). Simplifying:[v\u2081 = \\sqrt{\\frac{G M}{r}}] This velocity depends on the mass of the celestial body and the orbital radius. Second Cosmic Velocity (Escape Velocity): Escape velocity is derived by setting the object's total mechanical energy to zero (kinetic energy equals the magnitude of gravitational potential energy):[\\frac{1}{2} m v\u2082\u00b2 = \\frac{G M m}{r}][v\u2082 = \\sqrt{\\frac{2 G M}{r}}] Note that (v\u2082 = \\sqrt{2} \\cdot v\u2081), meaning escape velocity is (\\sqrt{2}) times the orbital velocity. Parameters: Depends on (M) and (r), independent of the object's mass. Third Cosmic Velocity: This velocity is more complex, as it involves escaping the star's (e.g., Sun's) gravitational pull from the planet's orbital distance. For an object starting from a planet's surface, it must first reach the planet's escape velocity and then gain additional speed to escape the star's gravity. Approximate formula (simplified, assuming the planet's orbit is circular):[v\u2083 = \\sqrt{v\u2082\u00b2 + v_{\\text{esc,Sun}}^2}]where (v_{\\text{esc,Sun}}) is the escape velocity from the Sun at the planet's orbital distance (d):[v_{\\text{esc,Sun}} = \\sqrt{\\frac{2 G M_{\\text{Sun}}}{d}}] For precise calculations, orbital mechanics and energy conservation are used, accounting for the planet's velocity in its orbit around the Sun. Parameters Affecting Velocities Mass of the Celestial Body (M): Higher mass increases gravitational pull, increasing all cosmic velocities. Radius of the Celestial Body (r): Larger radius reduces velocities (since gravity weakens with distance). Orbital Distance from the Star (d): For (v\u2083), a larger distance from the star (e.g., Sun) reduces the velocity needed to escape the star system. Gravitational Constant (G): Universal constant scaling the gravitational force. Python Implementation and Visualization The following Python script calculates and visualizes the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. import numpy as np import matplotlib.pyplot as plt Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2)M_SUN = 1.989e30 # Mass of the Sun (kg) Celestial body data: [mass (kg), radius (m), orbital distance from Sun (m)] bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6, \"orbital_distance\": 1.496e11}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.390e6, \"orbital_distance\": 2.279e11}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.991e7, \"orbital_distance\": 7.785e11}} Calculate cosmic velocities def calculate_cosmic_velocities(body): M = body[\"mass\"] r = body[\"radius\"] d = body[\"orbital_distance\"] First cosmic velocity (orbital velocity) v1 = np.sqrt(G * M / r) / 1000 # Convert to km/s Second cosmic velocity (escape velocity) v2 = np.sqrt(2 * G * M / r) / 1000 # Convert to km/s Third cosmic velocity (approximate) v_esc_sun = np.sqrt(2 * G * M_SUN / d) / 1000 # Escape velocity from Sun at orbital distance v3 = np.sqrt(v2 2 + v_esc_sun 2) # Simplified third cosmic velocity return v1, v2, v3 Compute velocities for all bodies results = {name: calculate_cosmic_velocities(data) for name, data in bodies.items()} Visualization fig, ax = plt.subplots(figsize=(10, 6))bar_width = 0.25x = np.arange(len(bodies))v1s = [results[name][0] for name in bodies]v2s = [results[name][1] for name in bodies]v3s = [results[name][2] for name in bodies] ax.bar(x - bar_width, v1s, bar_width, label=\"First Cosmic Velocity (v\u2081)\", color=\"blue\")ax.bar(x, v2s, bar_width, label=\"Second Cosmic Velocity (v\u2082)\", color=\"green\")ax.bar(x + bar_width, v3s, bar_width, label=\"Third Cosmic Velocity (v\u2083)\", color=\"red\") ax.set_xlabel(\"Celestial Body\")ax.set_ylabel(\"Velocity (km/s)\")ax.set_title(\"Cosmic Velocities for Earth, Mars, and Jupiter\")ax.set_xticks(x)ax.set_xticklabels(bodies.keys())ax.legend()plt.tight_layout()plt.savefig(\"cosmic_velocities.png\")plt.show() Print results for name, (v1, v2, v3) in results.items(): print(f\"{name}:\") print(f\" First Cosmic Velocity: {v1:.2f} km/s\") print(f\" Second Cosmic Velocity: {v2:.2f} km/s\") print(f\" Third Cosmic Velocity: {v3:.2f} km/s\")","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"Escape Velocities and Cosmic Velocities Definitions and Physical Meaning First Cosmic Velocity (v\u2081): The minimum speed required for an object to achieve a stable circular orbit around a celestial body at a low altitude (close to the surface). It is also known as the orbital velocity. The object remains bound to the body but orbits without falling back. Second Cosmic Velocity (v\u2082): The escape velocity, the minimum speed needed for an object to escape the gravitational pull of a celestial body and move into interplanetary space without further propulsion. At this speed, the object's kinetic energy equals its gravitational potential energy at the surface. Third Cosmic Velocity (v\u2083): The minimum speed required for an object to escape the gravitational influence of a star system (e.g., the Solar System) and travel into interstellar space. This velocity accounts for escaping both the planet's gravity and the star's gravity from the planet's orbit. Mathematical Derivations First Cosmic Velocity (Orbital Velocity): For a circular orbit, the centripetal force required for circular motion is provided by gravitational attraction:[\\frac{m v\u2081\u00b2}{r} = \\frac{G M m}{r\u00b2}]where (m) is the mass of the object, (M) is the mass of the celestial body, (r) is the radius of the orbit (approximately the body's radius for low orbits), and (G) is the gravitational constant ((G = 6.67430 \\times 10^{-11} , \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2})). Simplifying:[v\u2081 = \\sqrt{\\frac{G M}{r}}] This velocity depends on the mass of the celestial body and the orbital radius. Second Cosmic Velocity (Escape Velocity): Escape velocity is derived by setting the object's total mechanical energy to zero (kinetic energy equals the magnitude of gravitational potential energy):[\\frac{1}{2} m v\u2082\u00b2 = \\frac{G M m}{r}][v\u2082 = \\sqrt{\\frac{2 G M}{r}}] Note that (v\u2082 = \\sqrt{2} \\cdot v\u2081), meaning escape velocity is (\\sqrt{2}) times the orbital velocity. Parameters: Depends on (M) and (r), independent of the object's mass. Third Cosmic Velocity: This velocity is more complex, as it involves escaping the star's (e.g., Sun's) gravitational pull from the planet's orbital distance. For an object starting from a planet's surface, it must first reach the planet's escape velocity and then gain additional speed to escape the star's gravity. Approximate formula (simplified, assuming the planet's orbit is circular):[v\u2083 = \\sqrt{v\u2082\u00b2 + v_{\\text{esc,Sun}}^2}]where (v_{\\text{esc,Sun}}) is the escape velocity from the Sun at the planet's orbital distance (d):[v_{\\text{esc,Sun}} = \\sqrt{\\frac{2 G M_{\\text{Sun}}}{d}}] For precise calculations, orbital mechanics and energy conservation are used, accounting for the planet's velocity in its orbit around the Sun. Parameters Affecting Velocities Mass of the Celestial Body (M): Higher mass increases gravitational pull, increasing all cosmic velocities. Radius of the Celestial Body (r): Larger radius reduces velocities (since gravity weakens with distance). Orbital Distance from the Star (d): For (v\u2083), a larger distance from the star (e.g., Sun) reduces the velocity needed to escape the star system. Gravitational Constant (G): Universal constant scaling the gravitational force. Python Implementation and Visualization The following Python script calculates and visualizes the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. import numpy as np import matplotlib.pyplot as plt Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2)M_SUN = 1.989e30 # Mass of the Sun (kg) Celestial body data: [mass (kg), radius (m), orbital distance from Sun (m)] bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6, \"orbital_distance\": 1.496e11}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.390e6, \"orbital_distance\": 2.279e11}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.991e7, \"orbital_distance\": 7.785e11}} Calculate cosmic velocities def calculate_cosmic_velocities(body): M = body[\"mass\"] r = body[\"radius\"] d = body[\"orbital_distance\"]","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-orbital-velocity","text":"v1 = np.sqrt(G * M / r) / 1000 # Convert to km/s","title":"First cosmic velocity (orbital velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"v2 = np.sqrt(2 * G * M / r) / 1000 # Convert to km/s","title":"Second cosmic velocity (escape velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-approximate","text":"v_esc_sun = np.sqrt(2 * G * M_SUN / d) / 1000 # Escape velocity from Sun at orbital distance v3 = np.sqrt(v2 2 + v_esc_sun 2) # Simplified third cosmic velocity return v1, v2, v3 Compute velocities for all bodies results = {name: calculate_cosmic_velocities(data) for name, data in bodies.items()} Visualization fig, ax = plt.subplots(figsize=(10, 6))bar_width = 0.25x = np.arange(len(bodies))v1s = [results[name][0] for name in bodies]v2s = [results[name][1] for name in bodies]v3s = [results[name][2] for name in bodies] ax.bar(x - bar_width, v1s, bar_width, label=\"First Cosmic Velocity (v\u2081)\", color=\"blue\")ax.bar(x, v2s, bar_width, label=\"Second Cosmic Velocity (v\u2082)\", color=\"green\")ax.bar(x + bar_width, v3s, bar_width, label=\"Third Cosmic Velocity (v\u2083)\", color=\"red\") ax.set_xlabel(\"Celestial Body\")ax.set_ylabel(\"Velocity (km/s)\")ax.set_title(\"Cosmic Velocities for Earth, Mars, and Jupiter\")ax.set_xticks(x)ax.set_xticklabels(bodies.keys())ax.legend()plt.tight_layout()plt.savefig(\"cosmic_velocities.png\")plt.show() Print results for name, (v1, v2, v3) in results.items(): print(f\"{name}:\") print(f\" First Cosmic Velocity: {v1:.2f} km/s\") print(f\" Second Cosmic Velocity: {v2:.2f} km/s\") print(f\" Third Cosmic Velocity: {v3:.2f} km/s\")","title":"Third cosmic velocity (approximate)"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Algorithm for Calculating Equivalent Resistance Using Graph Theory Overview This algorithm uses graph theory to calculate the equivalent resistance of a resistor network. The circuit is represented as an undirected graph where vertices are nodes (junctions) and edges are resistors with associated resistance values. The algorithm iteratively simplifies the graph by identifying and reducing series and parallel resistor combinations until a single equivalent resistance remains between the source and sink nodes. Pseudocode Algorithm CalculateEquivalentResistance(graph G, source s, sink t) Input: Graph G(V, E) with edges labeled by resistance values, source node s, sink node t Output: Equivalent resistance between s and t // Initialize equivalent_resistance = 0 G' = copy of G // Working copy of the graph While G' has more than two nodes (s and t) or more than one edge between s and t: // Step 1: Identify series connections for each node n in G' (excluding s and t): if degree(n) == 2: // Node connects exactly two resistors neighbors = {u, v} where (u, n) and (n, v) are edges r1 = resistance of edge (u, n) r2 = resistance of edge (n, v) // Replace series connection with single resistor Remove node n and edges (u, n), (n, v) Add edge (u, v) with resistance r1 + r2 // Step 2: Identify parallel connections for each pair of nodes (u, v) in G': if multiple edges exist between u and v: parallel_resistances = {r_i for each edge (u, v)} // Calculate equivalent parallel resistance r_eq = 1 / (sum(1/r_i for r_i in parallel_resistances)) // Replace parallel edges with single edge Remove all edges between u and v Add edge (u, v) with resistance r_eq // Step 3: Check for convergence if no series or parallel reductions were made: Break // Avoid infinite loop if graph cannot be simplified further // Final step: Handle remaining edge(s) between s and t if G' has one edge (s, t): equivalent_resistance = resistance of edge (s, t) else if G' has multiple edges between s and t: parallel_resistances = {r_i for each edge (s, t)} equivalent_resistance = 1 / (sum(1/r_i for r_i in parallel_resistances)) else: equivalent_resistance = infinity // No path exists Return equivalent_resistance Explanation The algorithm iteratively simplifies the graph by: Series Reduction: Identifies nodes with degree 2 (connected to exactly two resistors). These represent resistors in series. The node is removed, and the two resistors are replaced with a single edge whose resistance is the sum of the two (R1 + R2). Parallel Reduction: Identifies multiple edges between the same pair of nodes, indicating resistors in parallel. These are replaced with a single edge whose resistance is calculated using the parallel formula: 1/R_eq = 1/R1 + 1/R2 + ... + 1/Rn. Convergence Check: If no reductions are possible, the algorithm stops to avoid infinite loops, which can occur in complex graphs with cycles that cannot be reduced to series or parallel combinations alone. Final Output: Once the graph is reduced to a single edge (or multiple parallel edges) between the source and sink, the equivalent resistance is computed. Handling Nested Combinations Nested series and parallel combinations are handled naturally through iterative reduction: Series in Parallel: If a subgraph contains a series chain (e.g., R1 + R2) in parallel with another resistor (R3), the series reduction first combines R1 and R2 into a single resistor (R1 + R2). Then, the parallel reduction combines this with R3 using the parallel formula. Parallel in Series: If parallel resistors (e.g., R1 || R2) are in series with another resistor (R3), the parallel reduction first computes the equivalent resistance of R1 || R2, and then the series reduction adds R3. The iterative nature ensures that nested structures are simplified layer by layer, as each reduction step exposes new series or parallel patterns. Example Cases Simple Series and Parallel: Input: Three resistors: R1 = 2\u03a9, R2 = 3\u03a9 in series, in parallel with R3 = 6\u03a9. Process: Series: Combine R1 and R2 \u2192 2 + 3 = 5\u03a9. Parallel: Combine 5\u03a9 || 6\u03a9 \u2192 1/(1/5 + 1/6) = 30/11 \u2248 2.727\u03a9. Output: ~2.727\u03a9. Nested Configuration: Input: R1 = 4\u03a9 in series with a parallel combination of R2 = 8\u03a9 and R3 = 8\u03a9. Process: Parallel: R2 || R3 = 1/(1/8 + 1/8) = 4\u03a9. Series: 4\u03a9 + 4\u03a9 = 8\u03a9. Output: 8\u03a9. Complex Graph with Cycles: Input: A Wheatstone bridge-like graph with five resistors (R1 = 1\u03a9, R2 = 2\u03a9, R3 = 3\u03a9, R4 = 4\u03a9, R5 = 5\u03a9) forming a cycle with a cross resistor. Process: If reducible to series/parallel, iteratively simplify (e.g., reduce parallel paths or series chains). If non-reducible (like a Wheatstone bridge), the algorithm may terminate early, indicating a need for advanced techniques (e.g., Kirchhoff\u2019s laws). For simplicity, assume a reducible cycle: Combine series paths (e.g., R1 + R2), then parallel with R5, and so on. Output: Depends on specific configuration, but follows series/parallel rules. Efficiency Analysis Time Complexity: Series reduction: O(V) per iteration (checking degrees of all vertices). Parallel reduction: O(E) per iteration (checking edges for multiplicity). Iterations depend on graph size and structure, typically O(V + E) per iteration, with up to O(V) iterations in worst cases (linear chains). Overall: O(V * (V + E)). Space Complexity: O(V + E) for storing the graph and its copy. Limitations: The algorithm assumes the graph can be reduced using only series and parallel combinations. Non-reducible graphs (e.g., Wheatstone bridges) require additional techniques like delta-star transformations or solving linear equations (Kirchhoff\u2019s laws). Improvements: Use a priority queue to prioritize reductions (e.g., series before parallel). Incorporate delta-star transformations for non-reducible graphs. Leverage graph libraries like NetworkX for efficient traversal and manipulation.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Uzunluk (L, m): A\u00e7\u0131 (\u03b8, derece): S\u00fcre (s): const canvas = document.getElementById(\"canvas\"); const ctx = canvas.getContext(\"2d\"); const g = 9.81; // Yer\u00e7ekimi ivmesi const dt = 0.02; let t = 0; function getParams() { return { L: parseFloat(document.getElementById(\"length\").value), angle: parseFloat(document.getElementById(\"angle\").value) * Math.PI / 180, duration: parseFloat(document.getElementById(\"duration\").value) }; } function drawPendulum(x, y) { ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.beginPath(); ctx.moveTo(canvas.width / 2, 0); ctx.lineTo(x, y); ctx.stroke(); ctx.beginPath(); ctx.arc(x, y, 10, 0, 2 * Math.PI); ctx.fill(); } function animate() { const { L, angle, duration } = getParams(); const omega = Math.sqrt(g / L); const theta = angle * Math.cos(omega * t); const x = canvas.width / 2 + L * 100 * Math.sin(theta); const y = L * 100 * Math.cos(theta); drawPendulum(x, y); if (t < duration) { t += dt; requestAnimationFrame(animate); } } document.querySelectorAll(\"input\").forEach(input => { input.addEventListener(\"change\", () => { t = 0; animate(); }); }); animate(); // Ba\u015flang\u0131\u00e7 animasyonu","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}