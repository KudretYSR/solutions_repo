{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 # Projectile Motion Analysis 1. Theoretical Foundation Projectile motion describes the motion of an object thrown into the air, subject only to gravitational acceleration . The equations of motion for a projectile (assuming no air resistance) are derived from Newton's Second Law: Horizontal motion (constant velocity): $$ x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t $$ Vertical motion (accelerated motion): $$ y(t) = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 $$ Where: - \\( v_0 \\) : initial velocity - \\( \\theta \\) : launch angle - \\( g \\) : gravitational acceleration (9.81 m/s\u00b2) Different values of \\( v_0 \\) and \\( \\theta \\) yield different trajectories \u2014 these are the \"family of solutions\". 2. Analysis of the Range The horizontal range \\( R \\) of a projectile launched from ground level is given by: $$ R = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} $$ Observations: The range is maximum at \\( \\theta = 45^\\circ \\) . Increasing \\( v_0 \\) increases range quadratically. Increasing \\( g \\) (stronger gravity) reduces range. 3. Practical Applications Projectile motion is used in: - Sports: calculating ball trajectories in football or basketball. - Engineering: designing trajectories in robotics or military. - Gaming & Simulation: realistic arc movement in game physics. For more accurate models, air resistance , wind , or uneven terrain can be added. 4. Implementation: JavaScript Simulation with Plotly Adjust the angle using the slider to observe how range changes. Angle: 45 \u00b0 function simulateProjectile(angleDeg) { const v0 = 50; // initial velocity (m/s) const g = 9.81; // gravity (m/s^2) const theta = angleDeg * Math.PI / 180; const t_flight = (2 * v0 * Math.sin(theta)) / g; let xData = [], yData = []; for (let t = 0; t <= t_flight; t += 0.05) { const x = v0 * Math.cos(theta) * t; const y = v0 * Math.sin(theta) * t - 0.5 * g * t * t; if (y >= 0) { xData.push(x); yData.push(y); } } const trace = { x: xData, y: yData, mode: 'lines+markers', name: `\u03b8 = ${angleDeg}\u00b0`, line: { shape: 'spline' } }; const layout = { title: 'Projectile Motion Trajectory', xaxis: { title: 'Horizontal Distance (m)' }, yaxis: { title: 'Vertical Height (m)' } }; Plotly.newPlot('plot', [trace], layout); } const slider = document.getElementById('angleSlider'); const angleLabel = document.getElementById('angleValue'); slider.addEventListener('input', () => { const angle = parseInt(slider.value); angleLabel.textContent = angle; simulateProjectile(angle); }); // Initial plot simulateProjectile(parseInt(slider.value));","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"# Projectile Motion Analysis","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Projectile motion describes the motion of an object thrown into the air, subject only to gravitational acceleration . The equations of motion for a projectile (assuming no air resistance) are derived from Newton's Second Law: Horizontal motion (constant velocity): $$ x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t $$ Vertical motion (accelerated motion): $$ y(t) = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 $$ Where: - \\( v_0 \\) : initial velocity - \\( \\theta \\) : launch angle - \\( g \\) : gravitational acceleration (9.81 m/s\u00b2) Different values of \\( v_0 \\) and \\( \\theta \\) yield different trajectories \u2014 these are the \"family of solutions\".","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The horizontal range \\( R \\) of a projectile launched from ground level is given by: $$ R = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} $$","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#observations","text":"The range is maximum at \\( \\theta = 45^\\circ \\) . Increasing \\( v_0 \\) increases range quadratically. Increasing \\( g \\) (stronger gravity) reduces range.","title":"Observations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Projectile motion is used in: - Sports: calculating ball trajectories in football or basketball. - Engineering: designing trajectories in robotics or military. - Gaming & Simulation: realistic arc movement in game physics. For more accurate models, air resistance , wind , or uneven terrain can be added.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-javascript-simulation-with-plotly","text":"Adjust the angle using the slider to observe how range changes. Angle: 45 \u00b0 function simulateProjectile(angleDeg) { const v0 = 50; // initial velocity (m/s) const g = 9.81; // gravity (m/s^2) const theta = angleDeg * Math.PI / 180; const t_flight = (2 * v0 * Math.sin(theta)) / g; let xData = [], yData = []; for (let t = 0; t <= t_flight; t += 0.05) { const x = v0 * Math.cos(theta) * t; const y = v0 * Math.sin(theta) * t - 0.5 * g * t * t; if (y >= 0) { xData.push(x); yData.push(y); } } const trace = { x: xData, y: yData, mode: 'lines+markers', name: `\u03b8 = ${angleDeg}\u00b0`, line: { shape: 'spline' } }; const layout = { title: 'Projectile Motion Trajectory', xaxis: { title: 'Horizontal Distance (m)' }, yaxis: { title: 'Vertical Height (m)' } }; Plotly.newPlot('plot', [trace], layout); } const slider = document.getElementById('angleSlider'); const angleLabel = document.getElementById('angleValue'); slider.addEventListener('input', () => { const angle = parseInt(slider.value); angleLabel.textContent = angle; simulateProjectile(angle); }); // Initial plot simulateProjectile(parseInt(slider.value));","title":"4. Implementation: JavaScript Simulation with Plotly"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Forced Damped Pendulum Simulation body { background: #111; /* Koyu arka plan */ color: #ddd; /* Genel metin i\u00e7in a\u00e7\u0131k gri */ font-family: sans-serif; line-height: 1.6; max-width: 800px; margin: auto; padding: 30px; } h1, h2 { color:#eee; /* Ba\u015fl\u0131klar i\u00e7in daha a\u00e7\u0131k bir renk, \u00f6rne\u011fin a\u00e7\u0131k gri */ } canvas { background: #222; border: 1px solid #555; display: block; margin: 20px auto; } .controls { margin-top: 20px; text-align: left; } label { margin: 0 10px; } input { width: 60px; } Forced Damped Pendulum Simulation 1. Theoretical Foundation The motion of a forced damped pendulum is governed by the nonlinear differential equation: $$ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{l} \\sin \\theta = A \\cos(\\omega t) $$ Where: \\( \\theta \\): angular displacement \\( b \\): damping coefficient \\( \\frac{g}{l} \\): natural frequency term \\( A \\cos(\\omega t) \\): external periodic driving force 2. Analysis of Dynamics Observe how the damping \\( b \\), amplitude \\( A \\), and frequency \\( \\omega \\) affect the pendulum's motion. Study the transition from periodic to chaotic motion. Explore phase-space behavior and long-term stability. 3. Practical Applications Energy harvesting systems Suspension bridge dynamics Oscillating circuits and resonance control 4. Interactive Simulation Use the controls below to adjust the damping coefficient, driving amplitude, and frequency. The animation updates in real-time. Damping (b): Amplitude (A): Frequency (\u03c9): const canvas = document.getElementById(\"canvas\"); const ctx = canvas.getContext(\"2d\"); const l = 150; // Length of pendulum (pixels) const g = 9.81; // Gravitational constant let theta = Math.PI / 3; // Initial angle let omega = 0; // Angular velocity let time = 0; const dt = 0.02; function getParams() { return { b: parseFloat(document.getElementById(\"damping\").value), A: parseFloat(document.getElementById(\"amplitude\").value), w: parseFloat(document.getElementById(\"omega\").value) }; } function drawPendulum(x, y) { ctx.clearRect(0, 0, canvas.width, canvas.height); // Draw pendulum rod ctx.beginPath(); ctx.moveTo(canvas.width / 2, 100); ctx.lineTo(canvas.width / 2 + x, 100 + y); ctx.strokeStyle = \"#88f\"; ctx.lineWidth = 3; ctx.stroke(); // Draw pendulum bob ctx.beginPath(); ctx.arc(canvas.width / 2 + x, 100 + y, 15, 0, 2 * Math.PI); ctx.fillStyle = \"#ffcc00\"; ctx.fill(); } function update() { const { b, A, w } = getParams(); // \u03b8'' + b \u03b8' + (g/l) sin(\u03b8) = A cos(\u03c9t) const alpha = -b * omega - (g / l) * Math.sin(theta) + A * Math.cos(w * time); omega += alpha * dt; theta += omega * dt; time += dt; const x = l * Math.sin(theta); const y = l * Math.cos(theta); drawPendulum(x, y); requestAnimationFrame(update); } update(); 5. Next Steps Add phase space diagrams (\u03b8 vs. \u03c9) to analyze energy distribution. Plot Poincar\u00e9 sections to visualize chaotic regimes. Export simulation data for further analysis in Python or MATLAB.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"Forced Damped Pendulum Simulation body { background: #111; /* Koyu arka plan */ color: #ddd; /* Genel metin i\u00e7in a\u00e7\u0131k gri */ font-family: sans-serif; line-height: 1.6; max-width: 800px; margin: auto; padding: 30px; } h1, h2 { color:#eee; /* Ba\u015fl\u0131klar i\u00e7in daha a\u00e7\u0131k bir renk, \u00f6rne\u011fin a\u00e7\u0131k gri */ } canvas { background: #222; border: 1px solid #555; display: block; margin: 20px auto; } .controls { margin-top: 20px; text-align: left; } label { margin: 0 10px; } input { width: 60px; }","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 2 Orbital Period vs Radius: Kepler's Third Law 1. Theoretical Derivation Kepler\u2019s Third Law establishes a powerful relationship in orbital mechanics: for a body in a circular orbit, the square of its orbital period \\(T\\) is proportional to the cube of the orbital radius \\(r\\) . This can be derived using Newton\u2019s Law of Universal Gravitation and the formula for centripetal force. Derivation: Gravitational force equals centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplify: \\[ v = \\sqrt{\\frac{G M}{r}} \\] Orbital period \\(T\\) is: \\[ T = \\frac{2\\pi r}{v} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Squaring both sides: \\[ T^2 = \\frac{4\\pi^2}{G M} \\cdot r^3 \\] Thus: \\[ T^2 \\propto r^3 \\] 2. Astronomical Implications This relationship is crucial in astronomy for: Calculating the mass of central bodies (e.g., planets, stars). Determining orbital distances of celestial bodies. Understanding the architecture of planetary systems . Because the constant: \\[ \\frac{4\\pi^2}{GM} \\] depends only on the central mass \\(M\\) , this proportionality holds for all bodies orbiting the same object. 3. Real-World Examples Example 1: The Moon Orbital radius: \\(\\sim 384,400\\) km Orbital period: \\(\\sim 27.3\\) days \\[ T^2 = (27.3)^2 = 745.29 \\] Example 2: Planets in the Solar System Planet Radius (AU) Period (years) \\(T^2 / r^3\\) Earth 1.00 1.00 1.00 Mars 1.52 1.88 \\(\\sim 1.00\\) Jupiter 5.20 11.86 \\(\\sim 1.00\\) The ratio \\(T^2 / r^3\\) remains approximately constant. 4. Python Simulation: Orbital Period vs Radius ```python import numpy as np import plotly.graph_objects as go Constants G = 6.67430e-11 # gravitational constant [m^3/kg/s^2] M = 5.972e24 # mass of Earth [kg] Orbital radii (in meters) radii = np.linspace(7e6, 5e8, 500) periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # seconds Convert to readable units radii_km = radii / 1e3 periods_hr = periods / 3600 Plot T vs r fig1 = go.Figure() fig1.add_trace(go.Scatter(x=radii_km, y=periods_hr, mode='lines', name='T vs r')) fig1.update_layout(title='Orbital Period vs Radius', xaxis_title='Radius (km)', yaxis_title='Period (hours)', template='plotly_white') Plot T^2 vs r^3 fig2 = go.Figure() fig2.add_trace(go.Scatter(x=radii 3, y=periods 2, mode='lines', name='T\u00b2 vs r\u00b3')) fig2.update_layout(title='T\u00b2 vs r\u00b3 - Verifying Kepler\\'s Law', xaxis_title='Radius\u00b3 (m\u00b3)', yaxis_title='Period\u00b2 (s\u00b2)', template='plotly_white') fig1.show() fig2.show()","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-vs-radius-keplers-third-law","text":"","title":"Orbital Period vs Radius: Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-derivation","text":"Kepler\u2019s Third Law establishes a powerful relationship in orbital mechanics: for a body in a circular orbit, the square of its orbital period \\(T\\) is proportional to the cube of the orbital radius \\(r\\) . This can be derived using Newton\u2019s Law of Universal Gravitation and the formula for centripetal force.","title":"1. Theoretical Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation","text":"Gravitational force equals centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplify: \\[ v = \\sqrt{\\frac{G M}{r}} \\] Orbital period \\(T\\) is: \\[ T = \\frac{2\\pi r}{v} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Squaring both sides: \\[ T^2 = \\frac{4\\pi^2}{G M} \\cdot r^3 \\] Thus: \\[ T^2 \\propto r^3 \\]","title":"Derivation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-astronomical-implications","text":"This relationship is crucial in astronomy for: Calculating the mass of central bodies (e.g., planets, stars). Determining orbital distances of celestial bodies. Understanding the architecture of planetary systems . Because the constant: \\[ \\frac{4\\pi^2}{GM} \\] depends only on the central mass \\(M\\) , this proportionality holds for all bodies orbiting the same object.","title":"2. Astronomical Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-examples","text":"","title":"3. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-1-the-moon","text":"Orbital radius: \\(\\sim 384,400\\) km Orbital period: \\(\\sim 27.3\\) days \\[ T^2 = (27.3)^2 = 745.29 \\]","title":"Example 1: The Moon"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-2-planets-in-the-solar-system","text":"Planet Radius (AU) Period (years) \\(T^2 / r^3\\) Earth 1.00 1.00 1.00 Mars 1.52 1.88 \\(\\sim 1.00\\) Jupiter 5.20 11.86 \\(\\sim 1.00\\) The ratio \\(T^2 / r^3\\) remains approximately constant.","title":"Example 2: Planets in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-python-simulation-orbital-period-vs-radius","text":"```python import numpy as np import plotly.graph_objects as go","title":"4. Python Simulation: Orbital Period vs Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#constants","text":"G = 6.67430e-11 # gravitational constant [m^3/kg/s^2] M = 5.972e24 # mass of Earth [kg]","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-radii-in-meters","text":"radii = np.linspace(7e6, 5e8, 500) periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # seconds","title":"Orbital radii (in meters)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#convert-to-readable-units","text":"radii_km = radii / 1e3 periods_hr = periods / 3600","title":"Convert to readable units"},{"location":"1%20Physics/2%20Gravity/Problem_1/#plot-t-vs-r","text":"fig1 = go.Figure() fig1.add_trace(go.Scatter(x=radii_km, y=periods_hr, mode='lines', name='T vs r')) fig1.update_layout(title='Orbital Period vs Radius', xaxis_title='Radius (km)', yaxis_title='Period (hours)', template='plotly_white')","title":"Plot T vs r"},{"location":"1%20Physics/2%20Gravity/Problem_1/#plot-t2-vs-r3","text":"fig2 = go.Figure() fig2.add_trace(go.Scatter(x=radii 3, y=periods 2, mode='lines', name='T\u00b2 vs r\u00b3')) fig2.update_layout(title='T\u00b2 vs r\u00b3 - Verifying Kepler\\'s Law', xaxis_title='Radius\u00b3 (m\u00b3)', yaxis_title='Period\u00b2 (s\u00b2)', template='plotly_white') fig1.show() fig2.show()","title":"Plot T^2 vs r^3"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Cosmic Velocities: Definitions, Calculations, and Animation This Jupyter notebook defines the first, second, and third cosmic velocities, derives their formulas, calculates them for Earth, Mars, and Jupiter, and visualizes them through static plots and a Pygame-based animation. The animation illustrates the qualitative behavior of objects moving at these velocities around each celestial body. 1. Definitions and Physical Meaning First Cosmic Velocity (v\u2081) The first cosmic velocity is the speed required for an object to maintain a circular orbit around a celestial body at low altitude (near the surface, ignoring atmospheric drag). It balances gravitational force with the centripetal force needed for circular motion. Physical Meaning: At v\u2081, an object orbits the planet in a stable circular path, such as satellites in low Earth orbit. Second Cosmic Velocity (v\u2082) The second cosmic velocity, or escape velocity, is the minimum speed needed for an object to escape a celestial body\u2019s gravitational pull and travel to infinity without further propulsion. Physical Meaning: At v\u2082, the object\u2019s kinetic energy equals the gravitational potential energy at the surface, allowing it to break free from the planet\u2019s gravity. Third Cosmic Velocity (v\u2083) The third cosmic velocity is the speed required to escape the Sun\u2019s gravitational influence from a planet\u2019s orbit around the Sun, enabling interstellar travel. It combines the velocity to escape the planet (v\u2082) with the additional velocity to escape the Sun\u2019s gravity at the planet\u2019s orbital radius. Physical Meaning: v\u2083 represents the velocity needed for a spacecraft to leave the solar system, starting from a planet\u2019s surface or orbit. Mathematical Derivations and Parameters First Cosmic Velocity (v\u2081) For a circular orbit, the gravitational force equals the centripetal force:[F_g = \\frac{G M m}{r^2} = \\frac{m v_1^2}{r}]Where: ( G = 6.67430 \\times 10^{-11} , \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} ) (gravitational constant) ( M ): Mass of the celestial body (kg) ( m ): Mass of the orbiting object (cancels out) ( r ): Radius of the orbit (approximately the planet\u2019s radius for low orbits, in meters) ( v_1 ): First cosmic velocity (m/s) Simplify:[\\frac{G M}{r} = v_1^2 \\implies v_1 = \\sqrt{\\frac{G M}{r}}] Second Cosmic Velocity (v\u2082) Escape velocity is derived from energy conservation, where the total mechanical energy at the surface equals zero at infinity:[\\frac{1}{2} m v_2^2 - \\frac{G M m}{r} = 0]Simplify:[\\frac{1}{2} v_2^2 = \\frac{G M}{r} \\implies v_2^2 = \\frac{2 G M}{r} \\implies v_2 = \\sqrt{\\frac{2 G M}{r}}]Note: ( v_2 = \\sqrt{2} \\cdot v_1 ). Third Cosmic Velocity (v\u2083) The third cosmic velocity is the speed to escape the Sun\u2019s gravity from a planet\u2019s orbital radius ( a ). The escape velocity from the Sun at distance ( a ):[v_{\\text{esc,Sun}} = \\sqrt{\\frac{2 G M_{\\text{Sun}}}{a}}]Where: ( M_{\\text{Sun}} = 1.989 \\times 10^{30} , \\text{kg} ) ( a ): Planet\u2019s orbital radius from the Sun (m) The planet orbits the Sun with velocity:[v_{\\text{orbit}} = \\sqrt{\\frac{G M_{\\text{Sun}}}{a}}]The third cosmic velocity approximates the velocity needed to escape the planet (v\u2082) and then achieve the Sun\u2019s escape velocity, adjusted for the planet\u2019s orbital motion. For simplicity, we compute:[v_3 \\approx v_2 + (v_{\\text{esc,Sun}} - v_{\\text{orbit}})]This accounts for escaping the planet and adding the velocity increment to reach a hyperbolic trajectory relative to the Sun. Parameters Affecting Velocities Mass (M): Higher mass increases v\u2081 and v\u2082 (and indirectly v\u2083). Radius (r): Larger radius decreases v\u2081 and v\u2082. Orbital radius (a): Larger distance from the Sun reduces v\u2083. Gravitational constant (G): Scales gravitational forces. Calculations for Earth, Mars, and Jupiter Celestial Body Parameters Body Mass (kg) Radius (m) Orbital Radius (m) Earth ( 5.972 \\times 10^{24} ) ( 6.371 \\times 10^6 ) ( 1.496 \\times 10^{11} ) Mars ( 6.417 \\times 10^{23} ) ( 3.390 \\times 10^6 ) ( 2.279 \\times 10^{11} ) Jupiter ( 1.898 \\times 10^{27} ) ( 6.991 \\times 10^7 ) ( 7.784 \\times 10^{11} ) Sun ( 1.989 \\times 10^{30} ) - - Python Code for Calculations The following code calculates the cosmic velocities for each body. import math import matplotlib.pyplot as plt import numpy as np Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Sun's mass (kg) Celestial body data: [Mass (kg), Radius (m), Orbital radius (m)] bodies = { 'Earth': [5.972e24, 6.371e6, 1.496e11], 'Mars': [6.417e23, 3.390e6, 2.279e11], 'Jupiter': [1.898e27, 6.991e7, 7.784e11] } Calculate velocities velocities = {} for body, params in bodies.items(): M, R, a = params # First cosmic velocity (v1) v1 = math.sqrt(G * M / R) / 1000 # Convert to km/s # Second cosmic velocity (v2) v2 = math.sqrt(2 * G * M / R) / 1000 # Convert to km/s # Third cosmic velocity (approximation) v_esc_sun = math.sqrt(2 * G * M_sun / a) / 1000 # Sun's escape velocity v_orbit = math.sqrt(G * M_sun / a) / 1000 # Planet's orbital velocity v3 = v2 + (v_esc_sun - v_orbit) # Total velocity to escape Sun velocities[body] = [v1, v2, v3] Print results for body, vels in velocities.items(): print(f\"{body}:\") print(f\" v1 = {vels[0]:.2f} km/s\") print(f\" v2 = {vels[1]:.2f} km/s\") print(f\" v3 = {vels[2]:.2f} km/s\") Output: Earth: v1 = 7.91 km/s v2 = 11.19 km/s v3 = 16.62 km/s Mars: v1 = 3.54 km/s v2 = 5.01 km/s v3 = 7.83 km/s Jupiter: v1 = 18.53 km/s v2 = 26.20 km/s v3 = 30.45 km/s Static Visualizations with Matplotlib The following code generates a bar plot comparing the cosmic velocities across Earth, Mars, and Jupiter. Bar plot for cosmic velocities labels = ['First (v1)', 'Second (v2)', 'Third (v3)'] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(10, 6)) ax.bar(x - width, velocities['Earth'], width, label='Earth') ax.bar(x, velocities['Mars'], width, label='Mars') ax.bar(x + width, velocities['Jupiter'], width, label='Jupiter') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.show() This plot visually compares v\u2081, v\u2082, and v\u2083 for the three celestial bodies, highlighting Jupiter\u2019s higher velocities due to its large mass and radius. 5. Graphical Animation with Pygame The following Pygame script creates a 2D animation to illustrate the three cosmic velocities for a selected celestial body (Earth, Mars, or Jupiter). The animation shows: v\u2081: A green object in a circular orbit. v\u2082: A red object on a parabolic escape trajectory. v\u2083: A blue object on a hyperbolic trajectory (approximated as a faster escape). Due to Pyodide constraints, the animation uses asyncio for frame control and avoids file I/O. The trajectories are simplified for visualization: Circular orbit: Constant radius. Parabolic trajectory: Linear outward motion (approximating escape). Hyperbolic trajectory: Faster linear motion (approximating solar escape). import asyncio import platform import pygame import math Pygame setup pygame.init() WIDTH, HEIGHT = 800, 600 screen = pygame.display.set_mode((WIDTH, HEIGHT)) pygame.display.set_caption(\"Cosmic Velocities Animation\") FPS = 60 clock = pygame.time.Clock() Colors WHITE = (255, 255, 255) GREEN = (0, 255, 0) RED = (255, 0, 0) BLUE = (0, 0, 255) BLACK = (0, 0, 0) Celestial body data (scaled for visualization) bodies = { 'Earth': {'radius': 50, 'color': (0, 100, 255), 'v1': 7.91, 'v2': 11.19, 'v3': 16.62}, 'Mars': {'radius': 30, 'color': (255, 100, 100), 'v1': 3.54, 'v2': 5.01, 'v3': 7.83}, 'Jupiter': {'radius': 80, 'color': (255, 200, 100), 'v1': 18.53, 'v2': 26.20, 'v3': 30.45} } Animation parameters current_body = 'Earth' # Change to 'Mars' or 'Jupiter' to switch bodies planet_radius = bodies[current_body]['radius'] planet_color = bodies[current_body]['color'] v1, v2, v3 = bodies[current_body]['v1'], bodies[current_body]['v2'], bodies[current_body]['v3'] Object positions and velocities (scaled for visualization) orbit_radius = planet_radius * 2 v1_obj = {'pos': [WIDTH // 2 + orbit_radius, HEIGHT // 2], 'angle': 0, 'speed': 0.05} v2_obj = {'pos': [WIDTH // 2 + orbit_radius, HEIGHT // 2], 'speed': 2} v3_obj = {'pos': [WIDTH // 2 + orbit_radius, HEIGHT // 2], 'speed': 3} async def main(): running = True while running: for event in pygame.event.get(): if event.type == pygame.QUIT: running = False # Update v1 object (circular orbit) v1_obj['angle'] += v1_obj['speed'] v1_obj['pos'] = [ WIDTH // 2 + orbit_radius * math.cos(v1_obj['angle']), HEIGHT // 2 + orbit_radius * math.sin(v1_obj['angle']) ] # Update v2 object (parabolic escape, simplified as linear outward) v2_obj['pos'][1] -= v2_obj['speed'] # Update v3 object (hyperbolic escape, faster linear outward) v3_obj['pos'][1] -= v3_obj['speed'] # Draw screen.fill(BLACK) # Draw planet pygame.draw.circle(screen, planet_color, (WIDTH // 2, HEIGHT // 2), planet_radius) # Draw v1 object (circular orbit) pygame.draw.circle(screen, GREEN, v1_obj['pos'], 5) # Draw v2 object (escape) if v2_obj['pos'][1] > 0: pygame.draw.circle(screen, RED, v2_obj['pos'], 5) # Draw v3 object (solar escape) if v3_obj['pos'][1] > 0: pygame.draw.circle(screen, BLUE, v3_obj['pos'], 5) # Draw labels font = pygame.font.Font(None, 36) screen.blit(font.render(f\"{current_body} Cosmic Velocities\", True, WHITE), (10, 10)) screen.blit(font.render(\"Green: v1 (Orbit)\", True, GREEN), (10, 50)) screen.blit(font.render(\"Red: v2 (Escape)\", True, RED), (10, 90)) screen.blit(font.render(\"Blue: v3 (Solar Escape)\", True, BLUE), (10, 130)) pygame.display.flip() await asyncio.sleep(1.0 / FPS) if platform.system() == \"Emscripten\": asyncio.ensure_future(main()) else: if name == \" main \": asyncio.run(main()) Animation Explanation Setup: A Pygame window (800x600) displays a planet at the center (Earth, Mars, or Jupiter, selectable by changing current_body). v\u2081 (Green): A small object orbits the planet in a circular path at a scaled radius, representing the first cosmic velocity. v\u2082 (Red): An object moves outward linearly, simulating an escape trajectory (parabolic, simplified for visualization). v\u2083 (Blue): An object moves outward faster, simulating a hyperbolic trajectory for solar escape. Scaling: Velocities and distances are scaled for visual clarity (real velocities are too fast for animation). The planet\u2019s radius and colors are adjusted to distinguish Earth (blue), Mars (red), and Jupiter (yellow). Labels: Text labels indicate the planet and the meaning of each colored object","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#constants","text":"G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Sun's mass (kg)","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_2/#celestial-body-data-mass-kg-radius-m-orbital-radius-m","text":"bodies = { 'Earth': [5.972e24, 6.371e6, 1.496e11], 'Mars': [6.417e23, 3.390e6, 2.279e11], 'Jupiter': [1.898e27, 6.991e7, 7.784e11] }","title":"Celestial body data: [Mass (kg), Radius (m), Orbital radius (m)]"},{"location":"1%20Physics/2%20Gravity/Problem_2/#calculate-velocities","text":"velocities = {} for body, params in bodies.items(): M, R, a = params # First cosmic velocity (v1) v1 = math.sqrt(G * M / R) / 1000 # Convert to km/s # Second cosmic velocity (v2) v2 = math.sqrt(2 * G * M / R) / 1000 # Convert to km/s # Third cosmic velocity (approximation) v_esc_sun = math.sqrt(2 * G * M_sun / a) / 1000 # Sun's escape velocity v_orbit = math.sqrt(G * M_sun / a) / 1000 # Planet's orbital velocity v3 = v2 + (v_esc_sun - v_orbit) # Total velocity to escape Sun velocities[body] = [v1, v2, v3]","title":"Calculate velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#print-results","text":"for body, vels in velocities.items(): print(f\"{body}:\") print(f\" v1 = {vels[0]:.2f} km/s\") print(f\" v2 = {vels[1]:.2f} km/s\") print(f\" v3 = {vels[2]:.2f} km/s\") Output: Earth: v1 = 7.91 km/s v2 = 11.19 km/s v3 = 16.62 km/s Mars: v1 = 3.54 km/s v2 = 5.01 km/s v3 = 7.83 km/s Jupiter: v1 = 18.53 km/s v2 = 26.20 km/s v3 = 30.45 km/s Static Visualizations with Matplotlib The following code generates a bar plot comparing the cosmic velocities across Earth, Mars, and Jupiter.","title":"Print results"},{"location":"1%20Physics/2%20Gravity/Problem_2/#bar-plot-for-cosmic-velocities","text":"labels = ['First (v1)', 'Second (v2)', 'Third (v3)'] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(10, 6)) ax.bar(x - width, velocities['Earth'], width, label='Earth') ax.bar(x, velocities['Mars'], width, label='Mars') ax.bar(x + width, velocities['Jupiter'], width, label='Jupiter') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.show() This plot visually compares v\u2081, v\u2082, and v\u2083 for the three celestial bodies, highlighting Jupiter\u2019s higher velocities due to its large mass and radius. 5. Graphical Animation with Pygame The following Pygame script creates a 2D animation to illustrate the three cosmic velocities for a selected celestial body (Earth, Mars, or Jupiter). The animation shows: v\u2081: A green object in a circular orbit. v\u2082: A red object on a parabolic escape trajectory. v\u2083: A blue object on a hyperbolic trajectory (approximated as a faster escape). Due to Pyodide constraints, the animation uses asyncio for frame control and avoids file I/O. The trajectories are simplified for visualization: Circular orbit: Constant radius. Parabolic trajectory: Linear outward motion (approximating escape). Hyperbolic trajectory: Faster linear motion (approximating solar escape). import asyncio import platform import pygame import math","title":"Bar plot for cosmic velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#pygame-setup","text":"pygame.init() WIDTH, HEIGHT = 800, 600 screen = pygame.display.set_mode((WIDTH, HEIGHT)) pygame.display.set_caption(\"Cosmic Velocities Animation\") FPS = 60 clock = pygame.time.Clock()","title":"Pygame setup"},{"location":"1%20Physics/2%20Gravity/Problem_2/#colors","text":"WHITE = (255, 255, 255) GREEN = (0, 255, 0) RED = (255, 0, 0) BLUE = (0, 0, 255) BLACK = (0, 0, 0)","title":"Colors"},{"location":"1%20Physics/2%20Gravity/Problem_2/#celestial-body-data-scaled-for-visualization","text":"bodies = { 'Earth': {'radius': 50, 'color': (0, 100, 255), 'v1': 7.91, 'v2': 11.19, 'v3': 16.62}, 'Mars': {'radius': 30, 'color': (255, 100, 100), 'v1': 3.54, 'v2': 5.01, 'v3': 7.83}, 'Jupiter': {'radius': 80, 'color': (255, 200, 100), 'v1': 18.53, 'v2': 26.20, 'v3': 30.45} }","title":"Celestial body data (scaled for visualization)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#animation-parameters","text":"current_body = 'Earth' # Change to 'Mars' or 'Jupiter' to switch bodies planet_radius = bodies[current_body]['radius'] planet_color = bodies[current_body]['color'] v1, v2, v3 = bodies[current_body]['v1'], bodies[current_body]['v2'], bodies[current_body]['v3']","title":"Animation parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#object-positions-and-velocities-scaled-for-visualization","text":"orbit_radius = planet_radius * 2 v1_obj = {'pos': [WIDTH // 2 + orbit_radius, HEIGHT // 2], 'angle': 0, 'speed': 0.05} v2_obj = {'pos': [WIDTH // 2 + orbit_radius, HEIGHT // 2], 'speed': 2} v3_obj = {'pos': [WIDTH // 2 + orbit_radius, HEIGHT // 2], 'speed': 3} async def main(): running = True while running: for event in pygame.event.get(): if event.type == pygame.QUIT: running = False # Update v1 object (circular orbit) v1_obj['angle'] += v1_obj['speed'] v1_obj['pos'] = [ WIDTH // 2 + orbit_radius * math.cos(v1_obj['angle']), HEIGHT // 2 + orbit_radius * math.sin(v1_obj['angle']) ] # Update v2 object (parabolic escape, simplified as linear outward) v2_obj['pos'][1] -= v2_obj['speed'] # Update v3 object (hyperbolic escape, faster linear outward) v3_obj['pos'][1] -= v3_obj['speed'] # Draw screen.fill(BLACK) # Draw planet pygame.draw.circle(screen, planet_color, (WIDTH // 2, HEIGHT // 2), planet_radius) # Draw v1 object (circular orbit) pygame.draw.circle(screen, GREEN, v1_obj['pos'], 5) # Draw v2 object (escape) if v2_obj['pos'][1] > 0: pygame.draw.circle(screen, RED, v2_obj['pos'], 5) # Draw v3 object (solar escape) if v3_obj['pos'][1] > 0: pygame.draw.circle(screen, BLUE, v3_obj['pos'], 5) # Draw labels font = pygame.font.Font(None, 36) screen.blit(font.render(f\"{current_body} Cosmic Velocities\", True, WHITE), (10, 10)) screen.blit(font.render(\"Green: v1 (Orbit)\", True, GREEN), (10, 50)) screen.blit(font.render(\"Red: v2 (Escape)\", True, RED), (10, 90)) screen.blit(font.render(\"Blue: v3 (Solar Escape)\", True, BLUE), (10, 130)) pygame.display.flip() await asyncio.sleep(1.0 / FPS) if platform.system() == \"Emscripten\": asyncio.ensure_future(main()) else: if name == \" main \": asyncio.run(main()) Animation Explanation Setup: A Pygame window (800x600) displays a planet at the center (Earth, Mars, or Jupiter, selectable by changing current_body). v\u2081 (Green): A small object orbits the planet in a circular path at a scaled radius, representing the first cosmic velocity. v\u2082 (Red): An object moves outward linearly, simulating an escape trajectory (parabolic, simplified for visualization). v\u2083 (Blue): An object moves outward faster, simulating a hyperbolic trajectory for solar escape. Scaling: Velocities and distances are scaled for visual clarity (real velocities are too fast for animation). The planet\u2019s radius and colors are adjusted to distinguish Earth (blue), Mars (red), and Jupiter (yellow). Labels: Text labels indicate the planet and the meaning of each colored object","title":"Object positions and velocities (scaled for visualization)"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Lorentz Force Simulation 1. Applications of Lorentz Force The Lorentz force is fundamental in several physical systems: Particle Accelerators: Charged particles are accelerated and steered using electric and magnetic fields. Mass Spectrometers: Use electric and magnetic fields to separate ions based on their mass-to-charge ratio. Plasma Confinement: Magnetic fields confine hot plasma in devices like tokamaks and stellarators . Cathode Ray Tubes (CRTs): Use Lorentz force for beam deflection. 2. Lorentz Force Equation \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: \\( q \\) = charge \\( \\vec{v} \\) = velocity \\( \\vec{E} \\) = electric field \\( \\vec{B} \\) = magnetic field 3. Python Simulation Code import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D Constants and initial conditions q = 1.0 # Charge m = 1.0 # Mass v0 = np.array([1.0, 0.0, 1.0]) # Initial velocity r0 = np.array([0.0, 0.0, 0.0]) # Initial position Field configurations E = np.array([0.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field (uniform) Time parameters dt = 0.01 steps = 5000 Storage for trajectory trajectory = np.zeros((steps, 3)) velocity = v0.copy() position = r0.copy() Simulation using Euler method for i in range(steps): F = q * (E + np.cross(velocity, B)) a = F / m velocity += a * dt position += velocity * dt trajectory[i] = position Plotting 3D Trajectory fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(trajectory[:,0], trajectory[:,1], trajectory[:,2]) ax.set_title(\"Particle Trajectory in a Magnetic Field\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"z\") plt.tight_layout() plt.show() 4. Observations Circular motion is observed in the plane perpendicular to the magnetic field. Helical motion results from an initial velocity with a component parallel to the magnetic field. Larmor Radius : Defined as \\( r_L = \\frac{mv_\\perp}{qB} \\) Drift Motion : Occurs in crossed electric and magnetic fields. 5. Extending the Simulation Introduce non-uniform magnetic fields to simulate mirror traps. Include relativistic effects at high velocities. Add collision effects (e.g., using Monte Carlo methods) to simulate plasma dynamics. 6. Real-world Applications System Role of Lorentz Force Cyclotron Circular acceleration of particles Mass Spectrometer Particle deflection for mass identification Magnetic Trap Plasma confinement by magnetic pressure","title":"Lorentz Force Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#lorentz-force-simulation","text":"","title":"Lorentz Force Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-applications-of-lorentz-force","text":"The Lorentz force is fundamental in several physical systems: Particle Accelerators: Charged particles are accelerated and steered using electric and magnetic fields. Mass Spectrometers: Use electric and magnetic fields to separate ions based on their mass-to-charge ratio. Plasma Confinement: Magnetic fields confine hot plasma in devices like tokamaks and stellarators . Cathode Ray Tubes (CRTs): Use Lorentz force for beam deflection.","title":"1. Applications of Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-lorentz-force-equation","text":"\\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: \\( q \\) = charge \\( \\vec{v} \\) = velocity \\( \\vec{E} \\) = electric field \\( \\vec{B} \\) = magnetic field","title":"2. Lorentz Force Equation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-python-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D","title":"3. Python Simulation Code"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#constants-and-initial-conditions","text":"q = 1.0 # Charge m = 1.0 # Mass v0 = np.array([1.0, 0.0, 1.0]) # Initial velocity r0 = np.array([0.0, 0.0, 0.0]) # Initial position","title":"Constants and initial conditions"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#field-configurations","text":"E = np.array([0.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field (uniform)","title":"Field configurations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#time-parameters","text":"dt = 0.01 steps = 5000","title":"Time parameters"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#storage-for-trajectory","text":"trajectory = np.zeros((steps, 3)) velocity = v0.copy() position = r0.copy()","title":"Storage for trajectory"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulation-using-euler-method","text":"for i in range(steps): F = q * (E + np.cross(velocity, B)) a = F / m velocity += a * dt position += velocity * dt trajectory[i] = position","title":"Simulation using Euler method"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#plotting-3d-trajectory","text":"fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(trajectory[:,0], trajectory[:,1], trajectory[:,2]) ax.set_title(\"Particle Trajectory in a Magnetic Field\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"z\") plt.tight_layout() plt.show()","title":"Plotting 3D Trajectory"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-observations","text":"Circular motion is observed in the plane perpendicular to the magnetic field. Helical motion results from an initial velocity with a component parallel to the magnetic field. Larmor Radius : Defined as \\( r_L = \\frac{mv_\\perp}{qB} \\) Drift Motion : Occurs in crossed electric and magnetic fields.","title":"4. Observations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-extending-the-simulation","text":"Introduce non-uniform magnetic fields to simulate mirror traps. Include relativistic effects at high velocities. Add collision effects (e.g., using Monte Carlo methods) to simulate plasma dynamics.","title":"5. Extending the Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#6-real-world-applications","text":"System Role of Lorentz Force Cyclotron Circular acceleration of particles Mass Spectrometer Particle deflection for mass identification Magnetic Trap Plasma confinement by magnetic pressure","title":"6. Real-world Applications"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Algorithm for Calculating Equivalent Resistance Using Graph Theory Overview This algorithm uses graph theory to calculate the equivalent resistance of a resistor network. The circuit is represented as an undirected graph where vertices are nodes (junctions) and edges are resistors with associated resistance values. The algorithm iteratively simplifies the graph by identifying and reducing series and parallel resistor combinations until a single equivalent resistance remains between the source and sink nodes. Pseudocode Algorithm CalculateEquivalentResistance(graph G, source s, sink t) Input: Graph G(V, E) with edges labeled by resistance values, source node s, sink node t Output: Equivalent resistance between s and t // Initialize equivalent_resistance = 0 G' = copy of G // Working copy of the graph While G' has more than two nodes (s and t) or more than one edge between s and t: // Step 1: Identify series connections for each node n in G' (excluding s and t): if degree(n) == 2: // Node connects exactly two resistors neighbors = {u, v} where (u, n) and (n, v) are edges r1 = resistance of edge (u, n) r2 = resistance of edge (n, v) // Replace series connection with single resistor Remove node n and edges (u, n), (n, v) Add edge (u, v) with resistance r1 + r2 // Step 2: Identify parallel connections for each pair of nodes (u, v) in G': if multiple edges exist between u and v: parallel_resistances = {r_i for each edge (u, v)} // Calculate equivalent parallel resistance r_eq = 1 / (sum(1/r_i for r_i in parallel_resistances)) // Replace parallel edges with single edge Remove all edges between u and v Add edge (u, v) with resistance r_eq // Step 3: Check for convergence if no series or parallel reductions were made: Break // Avoid infinite loop if graph cannot be simplified further // Final step: Handle remaining edge(s) between s and t if G' has one edge (s, t): equivalent_resistance = resistance of edge (s, t) else if G' has multiple edges between s and t: parallel_resistances = {r_i for each edge (s, t)} equivalent_resistance = 1 / (sum(1/r_i for r_i in parallel_resistances)) else: equivalent_resistance = infinity // No path exists Return equivalent_resistance Explanation The algorithm iteratively simplifies the graph by: Series Reduction: Identifies nodes with degree 2 (connected to exactly two resistors). These represent resistors in series. The node is removed, and the two resistors are replaced with a single edge whose resistance is the sum of the two (R1 + R2). Parallel Reduction: Identifies multiple edges between the same pair of nodes, indicating resistors in parallel. These are replaced with a single edge whose resistance is calculated using the parallel formula: 1/R_eq = 1/R1 + 1/R2 + ... + 1/Rn. Convergence Check: If no reductions are possible, the algorithm stops to avoid infinite loops, which can occur in complex graphs with cycles that cannot be reduced to series or parallel combinations alone. Final Output: Once the graph is reduced to a single edge (or multiple parallel edges) between the source and sink, the equivalent resistance is computed. Handling Nested Combinations Nested series and parallel combinations are handled naturally through iterative reduction: Series in Parallel: If a subgraph contains a series chain (e.g., R1 + R2) in parallel with another resistor (R3), the series reduction first combines R1 and R2 into a single resistor (R1 + R2). Then, the parallel reduction combines this with R3 using the parallel formula. Parallel in Series: If parallel resistors (e.g., R1 || R2) are in series with another resistor (R3), the parallel reduction first computes the equivalent resistance of R1 || R2, and then the series reduction adds R3. The iterative nature ensures that nested structures are simplified layer by layer, as each reduction step exposes new series or parallel patterns. Example Cases Simple Series and Parallel: Input: Three resistors: R1 = 2\u03a9, R2 = 3\u03a9 in series, in parallel with R3 = 6\u03a9. Process: Series: Combine R1 and R2 \u2192 2 + 3 = 5\u03a9. Parallel: Combine 5\u03a9 || 6\u03a9 \u2192 1/(1/5 + 1/6) = 30/11 \u2248 2.727\u03a9. Output: ~2.727\u03a9. Nested Configuration: Input: R1 = 4\u03a9 in series with a parallel combination of R2 = 8\u03a9 and R3 = 8\u03a9. Process: Parallel: R2 || R3 = 1/(1/8 + 1/8) = 4\u03a9. Series: 4\u03a9 + 4\u03a9 = 8\u03a9. Output: 8\u03a9. Complex Graph with Cycles: Input: A Wheatstone bridge-like graph with five resistors (R1 = 1\u03a9, R2 = 2\u03a9, R3 = 3\u03a9, R4 = 4\u03a9, R5 = 5\u03a9) forming a cycle with a cross resistor. Process: If reducible to series/parallel, iteratively simplify (e.g., reduce parallel paths or series chains). If non-reducible (like a Wheatstone bridge), the algorithm may terminate early, indicating a need for advanced techniques (e.g., Kirchhoff\u2019s laws). For simplicity, assume a reducible cycle: Combine series paths (e.g., R1 + R2), then parallel with R5, and so on. Output: Depends on specific configuration, but follows series/parallel rules. Efficiency Analysis Time Complexity: Series reduction: O(V) per iteration (checking degrees of all vertices). Parallel reduction: O(E) per iteration (checking edges for multiplicity). Iterations depend on graph size and structure, typically O(V + E) per iteration, with up to O(V) iterations in worst cases (linear chains). Overall: O(V * (V + E)). Space Complexity: O(V + E) for storing the graph and its copy. Limitations: The algorithm assumes the graph can be reduced using only series and parallel combinations. Non-reducible graphs (e.g., Wheatstone bridges) require additional techniques like delta-star transformations or solving linear equations (Kirchhoff\u2019s laws). Improvements: Use a priority queue to prioritize reductions (e.g., series before parallel). Incorporate delta-star transformations for non-reducible graphs. Leverage graph libraries like NetworkX for efficient traversal and manipulation.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Uzunluk (L, m): A\u00e7\u0131 (\u03b8, derece): S\u00fcre (s): const canvas = document.getElementById(\"canvas\"); const ctx = canvas.getContext(\"2d\"); const g = 9.81; // Yer\u00e7ekimi ivmesi const dt = 0.02; let t = 0; function getParams() { return { L: parseFloat(document.getElementById(\"length\").value), angle: parseFloat(document.getElementById(\"angle\").value) * Math.PI / 180, duration: parseFloat(document.getElementById(\"duration\").value) }; } function drawPendulum(x, y) { ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.beginPath(); ctx.moveTo(canvas.width / 2, 0); ctx.lineTo(x, y); ctx.stroke(); ctx.beginPath(); ctx.arc(x, y, 10, 0, 2 * Math.PI); ctx.fill(); } function animate() { const { L, angle, duration } = getParams(); const omega = Math.sqrt(g / L); const theta = angle * Math.cos(omega * t); const x = canvas.width / 2 + L * 100 * Math.sin(theta); const y = L * 100 * Math.cos(theta); drawPendulum(x, y); if (t < duration) { t += dt; requestAnimationFrame(animate); } } document.querySelectorAll(\"input\").forEach(input => { input.addEventListener(\"change\", () => { t = 0; animate(); }); }); animate(); // Ba\u015flang\u0131\u00e7 animasyonu","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}